#!/usr/bin/perl
#
# MogileFS daemon
#
# Copyright 2004, Danga Interactive
# Copyright 2006, Six Apart Ltd.
#
# Authors:
#   Brad Fitzpatrick <brad@danga.com>
#   Brad Whitaker    <whitaker@danga.com>
#   Mark Smith       <junior@danga.com>
#
# License:
#   Artistic/GPLv2, at your choosing.
#

package Mgd;

# don't run as root
die "mogilefsd cannot be run as root\n"
    if $< == 0;

use strict;
use Getopt::Long;
use IO::Socket;
use Symbol;
use POSIX ":sys_wait_h"; # argument for waitpid
use POSIX;
use DBI;
use DBD::mysql;
use File::Copy ();
use Carp;
use File::Basename ();
use File::Path ();
use Sys::Syslog;
use Socket qw(MSG_NOSIGNAL);
use Time::HiRes qw(gettimeofday tv_interval);
use Net::Netmask;
use LWP::UserAgent;
use List::Util;

use lib 'lib';
use MogileFS::Connection::Client;

use MogileFS::Worker::Query;
use MogileFS::Worker::Delete;
use MogileFS::Worker::Replicate;
use MogileFS::Worker::Reaper;
use MogileFS::Worker::Monitor;

# this is incremented whenever the schema changes.  server will refuse
# to start-up with an old schema version
use constant SCHEMA_VERSION => 5;

#####################################################################
### C O N F I G
#####################################################################

use vars qw($dbh $DEFAULT_CONFIG $DEFAULT_MOG_ROOT $MOG_ROOT $MOGSTORED_STREAM_PORT $DEBUG $USE_HTTP $FLAG_NOSIGNAL);

$DEFAULT_CONFIG = "/etc/mogilefs/mogilefsd.conf";
$DEFAULT_MOG_ROOT = "/mnt/mogilefs";
$MOGSTORED_STREAM_PORT = 7501;
$DEBUG = 0;

# used in send() calls to request not to get SIGPIPEd
eval { $FLAG_NOSIGNAL = MSG_NOSIGNAL };

my (
    %cmdline,
    %cfgfile,
    $config,
    $skipconfig,
    $daemonize,
    $db_dsn,
    $db_user,
    $db_pass,
    $conf_port,
    $query_jobs,
    $delete_jobs,
    $replicate_jobs,
    $reaper_jobs,
    $monitor_jobs,
    $mog_root,
    $worker_port,
    $min_free_space,
    $max_disk_age,
    $node_timeout,          # time in seconds to wait for storage node responses
   );

our $default_mindevcount;

# Command-line options will override
Getopt::Long::Configure( "bundling" );
Getopt::Long::GetOptions(
    'c|config=s'    => \$config,
    's|skipconfig'  => \$skipconfig,
    'd|debug+'      => \$cmdline{debug},
    'D|daemon'      => \$cmdline{daemonize},
    'dsn=s'         => \$cmdline{db_dsn},
    'dbuser=s'      => \$cmdline{db_user},
    'dbpass=s'      => \$cmdline{db_pass},
    'r|mogroot=s'   => \$cmdline{mog_root},
    'p|confport=i'  => \$cmdline{conf_port},
    'w|workers=i'   => \$cmdline{query_jobs},
    'no_http'       => \$cmdline{no_http},
    'workerport=i'  => \$cmdline{worker_port},
    'maxdiskage=i'  => \$cmdline{max_disk_age},
    'minfreespace=i' => \$cmdline{min_free_space},
    'default_mindevcount=i' => \$cmdline{default_mindevcount},
    'node_timeout=i' => \$cmdline{node_timeout},
);

$config = $DEFAULT_CONFIG if !$config && -r $DEFAULT_CONFIG;

# Read the config file if one was specified
if ( $config && !$skipconfig ) {
    open my $cf, "<$config" or die "open: $config: $!";

    my $configLine = qr{
        ^\s*                    # Leading space
        (\w+)                   # Key
        \s+ =? \s*              # space + optional equal + optional space
        (.+?)                   # Value
        \s*$                    # Trailing space
    }x;

    my $linecount = 0;
    while (defined( my $line = <$cf> )) {
        $linecount++;
        next if $line =~ m{^\s*(#.*)?$};
        die "Malformed config file (line $linecount)" unless $line =~ $configLine;

        my ( $key, $value ) = ( $1, $2 );
        print STDERR "Setting '$key' to '$value'\n" if $cmdline{debug};
        $cfgfile{ $key } = $value;
    }

    close $cf;
}

### FUNCTION: choose_value( $name, $default[, $boolean] )
sub choose_value ($$;$) {
    my ( $name, $default, $boolean ) = @_;

    return $cmdline{$name} if defined $cmdline{$name};
    return $cfgfile{$name} if defined $cfgfile{$name};
    return $default;
}


# Fill in defaults for those values which were either loaded from config or
# specified on the command line. Command line takes precendence, then values in
# the config file, then the defaults.
$daemonize      = choose_value( 'daemonize', 0, 1 );
$db_dsn         = choose_value( 'db_dsn', "DBI:mysql:mogilefs" );
$db_user        = choose_value( 'db_user', "mogile" );
$db_pass        = choose_value( 'db_pass', "", 1 );
$conf_port      = choose_value( 'conf_port', 7001 );
$MOG_ROOT       = choose_value( 'mog_root', $DEFAULT_MOG_ROOT );
$query_jobs     = choose_value( 'listener_jobs', undef) || # undef if not present, then we
                  choose_value( 'query_jobs', 20 );       # fall back to query_jobs, new name
$delete_jobs    = choose_value( 'delete_jobs', 1 );
$replicate_jobs = choose_value( 'replicate_jobs', 1 );
$reaper_jobs    = choose_value( 'reaper_jobs', 1 );
$monitor_jobs   = choose_value( 'monitor_jobs', 1 );
$worker_port    = choose_value( 'worker_port', 7200 );
$min_free_space = choose_value( 'min_free_space', 100 );
$max_disk_age   = choose_value( 'max_disk_age', 5 );
$DEBUG          = choose_value( 'debug', 0, 1 );
$USE_HTTP       = ! choose_value( 'no_http', 0, 1);
$default_mindevcount = choose_value( 'default_mindevcount', 2 );
$node_timeout   = choose_value( 'node_timeout', 3 );

### initial setup
Mgd::validate_dbh();
my $dbh = Mgd::get_dbh();
unless ($dbh) {
    die <<NODB;
Error: unable to establish connection with your MogileFS database.

Please verify that you have correctly setup a configuration file or are
providing the correct information in order to reach the database and try
running the MogileFS server again.  If you haven't setup your database yet,
run 'mogdbsetup'.
NODB
}

my $sversion = $dbh->selectrow_array("SELECT value FROM server_settings WHERE field='schema_version'") || 0;
unless ($sversion == SCHEMA_VERSION) {
    my $exp = SCHEMA_VERSION;
    die "Server's database schema version of $sversion doesn't match expected value of $exp.  Halting.

Please run mogdbsetup to upgrade your schema.\n";
}

# we're done with this, so undef it before we start forking, as then
# maybe we'll end up with children having the same socket and everybody
# writing to it at the same time...
undef $dbh;

#####################################################################
### D A E M O N   F U N C T I O N S
#####################################################################

daemonize() if $daemonize;

# keep track of what all child pids are doing, and what jobs are being
# satisifed.
my %child  = ();    # pid -> job
my %todie  = ();    # pid -> 1 (lists pids that we've asked to die)
my %jobs   = ();    # jobname -> [ min, current ]
my $psock;          # IO::Socket::INET connection to parent (undef if parent)
my %streamcache;    # host -> IO::Socket::INET to mogstored
my $lastspawntime = 0; # time we last ran spawn_children sub
our $allkidsup = 0;  # if true, all our kids are running. set to 0 when a kid dies.
our $starttime = time; # time we got going
our %domaincache; # { domainname => { domainrow } }
our $domaincachetime = 0;
our $client_ip = undef; # client ip address
our $force_alt_zone = 0; # if on, force to use alternate zone (if it's defined)

# [ what we want to be at, what we are at ]
$jobs{'queryworker'} = [ $query_jobs, 0 ];
$jobs{'delete'} = [ $delete_jobs, 0 ];
$jobs{'replicate'} = [ $replicate_jobs, 0 ];
$jobs{'reaper'} = [ $reaper_jobs, 0 ];
$jobs{'monitor'} = [ $monitor_jobs, 0 ];

# open up our log
openlog('mogilefsd', 'pid', 'daemon');
Mgd::log('info', 'beginning run');

sub validate_dbh {
    return unless $dbh;
    my $id = $dbh->selectrow_array("SELECT CONNECTION_ID()");
    if (! $id) {
        # handle's dead.  don't use it.  (MySQL-ism above)
        undef $dbh;
    }
}

sub get_dbh {
    return $dbh ||= DBI->connect($db_dsn, $db_user, $db_pass, {
        PrintError => 0,
    });
}

# Install signal handlers.
$SIG{TERM}  = sub {
    print STDERR scalar keys %child, " children to kill.\n" if $DEBUG;
    my $count = kill( 'TERM' => keys %child );
    print STDERR "Sent SIGTERM to $count children.\n" if $DEBUG;
    exit 0;
};
$SIG{INT}  = sub {
    print STDERR scalar keys %child, " children to kill.\n" if $DEBUG;
    my $count = kill( 'INT' => keys %child );
    print STDERR "Sent SIGINT to $count children.\n" if $DEBUG;
    exit 0;
};
$SIG{PIPE} = 'IGNORE';  # catch them by hand

#############################################################################
## beginning of main execution path
#############################################################################

# setup server socket to listen for client connections
my $server = IO::Socket::INET->new(LocalPort => $conf_port,
                                   Type      => SOCK_STREAM,
                                   Proto     => 'tcp',
                                   Blocking  => 0,
                                   Reuse     => 1,
                                   Listen    => 10 )
    or die "Error creating socket: $@\n";

# accept handler for new clients
my $accept_handler = sub {
    my $csock = $server->accept();
    return unless $csock;

    printf( "Listen child making a Client for %d.\n", fileno($csock) )
        if $DEBUG >= 2;
    my $client = MogileFS::Connection::Client->new($csock);
    printf( "Client is %s\n", $client ) if $DEBUG >= 2;
};

# now setup socket for workers to connect to
my $wserver = IO::Socket::INET->new(LocalPort => $worker_port,
                                    LocalAddr => '127.0.0.1',
                                    Type      => SOCK_STREAM,
                                    Proto     => 'tcp',
                                    Blocking  => 0,
                                    Reuse     => 1,
                                    Listen    => 10 )
    or die "Error creating socket: $@\n";

# accept handler for new workers
my $waccept_handler = sub {
    my $csock = $wserver->accept();
    return unless $csock;

    printf( "Listen child making a Worker connection for %d.\n", fileno($csock) )
        if $DEBUG >= 2;
    my $client = WorkerConn->new($csock);
    printf( "Child is %s\n", $client ) if $DEBUG >= 2;
    Frontend->RegisterWorkerConn($client);
};

# thing to keep jobs alive
my $spawn_children = sub {
    # run only once per second
    return 1 unless time > $lastspawntime;
    $lastspawntime = time();

    # see if anybody has died, but don't hang up on doing so
    my $pid = waitpid -1, WNOHANG;
    return 1 if $pid <= 0 && $allkidsup;
    $allkidsup = 0; # know something died

    # when a child dies, figure out what it was doing
    # and note that job has one less worker
    my $job;
    if ($pid > -1 && ($job = delete $child{$pid})) {
        my $extra = $todie{$pid} ? "expected" : "UNEXPECTED";
        error("Child $pid ($job) died: $? ($extra)");
        Frontend->NoteDeadChild($pid);

        if (my $jobstat = $jobs{$job}) {
            # if the pid is in %todie, then we have asked it to shut down
            # and have already decremented the jobstat counter and don't
            # want to do it again
            unless (my $true = delete $todie{$pid}) {
                # decrement the count of currently running jobs
                $jobstat->[1]--;
            }
        }
    }

    # foreach job, fork enough children
    while (my ($job, $jobstat) = each %jobs) {
        my $need = $jobstat->[0] - $jobstat->[1];
        if ($need > 0) {
            error("Job $job has only $jobstat->[1], wants $jobstat->[0], making $need.");
            for (1..$need) {
                my $cpid = make_new_child($job);
                return 1 unless $cpid;
                $child{$cpid} = $job;

                # now increase the count of processes currently doing this job
                $jobstat->[1]++;
            }
        }
    }

    # if we got this far, all jobs have been re-created.  note that
    # so we avoid more CPU usage in this post-event-loop callback later
    $allkidsup = 1;

    # true value keeps us running:
    return 1;
};

# setup Danga::Socket to start handling connections
Danga::Socket->DebugLevel( 3 );
Danga::Socket->OtherFds( fileno($server)  => $accept_handler,
                  fileno($wserver) => $waccept_handler, );

# setup the post event loop callback to spawn jobs, and the timeout
Danga::Socket->SetLoopTimeout( 250 ); # 250 milliseconds
Danga::Socket->SetPostLoopCallback($spawn_children);

# and now, actually start listening for events
eval {
    print( "Starting event loop for frontend job on pid $$.\n" ) if $DEBUG;
    Danga::Socket->EventLoop();
};

if ( $@ ) { Mgd::log('err', "crash log: $@"); }
Mgd::log('info', 'ending run');
closelog();

#############################################################################
## end of main
#############################################################################

sub daemonize {
    my($pid, $sess_id, $i);

    ## Fork and exit parent
    if ($pid = fork) { exit 0; }

    ## Detach ourselves from the terminal
    croak "Cannot detach from controlling terminal"
        unless $sess_id = POSIX::setsid();

    ## Prevent possibility of acquiring a controling terminal
    $SIG{'HUP'} = 'IGNORE';
    if ($pid = fork) { exit 0; }

    ## Change working directory
    chdir "/";

    ## Clear file creation mask
    umask 0;

    print STDERR "Daemon running as pid $$.\n" if $DEBUG;

    ## Close open file descriptors
    close(STDIN);
    close(STDOUT);
    close(STDERR);

    ## Reopen stderr, stdout, stdin to /dev/null
    if ( $DEBUG ) {
        open(STDIN,  "+>/tmp/mogilefsd.log");
    } else {
        open(STDIN,  "+>/dev/null");
    }
    open(STDOUT, "+>&STDIN");
    open(STDERR, "+>&STDIN");
}

sub make_new_child {
    my $job = shift;

    my $pid;
    my $sigset;

    # block signal for fork
    $sigset = POSIX::SigSet->new(SIGINT);
    sigprocmask(SIG_BLOCK, $sigset)
        or return error("Can't block SIGINT for fork: $!");

    return error("fork failed creating $job: $!")
        unless defined ($pid = fork);

    if ($pid) {
        sigprocmask(SIG_UNBLOCK, $sigset)
            or return error("Can't unblock SIGINT for fork: $!");
        return $pid;
    }

    # as a child, we want to close these and ignore them
    close($server);
    close($wserver);

    $SIG{INT} = 'DEFAULT';
    $SIG{TERM} = 'DEFAULT';
    $0 .= " [$job]";

    # unblock signals
    sigprocmask(SIG_UNBLOCK, $sigset)
        or return error("Can't unblock SIGINT for fork: $!");

    # set our frontend into child mode
    Frontend->SetAsChild;

    # try to create a connection to the parent.  we die here because
    # we're the child and if we can't talk to the master we really need
    # to die so that a child isn't just sitting around without communication
    # to the parent.
    $psock = IO::Socket::INET->new(PeerAddr => "127.0.0.1",
                                   PeerPort => $worker_port,
                                   Type     => SOCK_STREAM,
                                   Proto    => 'tcp',)
        or die "Error creating socket to master: $@\n";
    $psock->write("$$ $job\n");

    my $class_suffix = {
        queryworker => "Query",
        delete      => "Delete",
        replicate   => "Replicate",
        reaper      => "Reaper",
        monitor     => "Monitor",
    }->{$job} or
        die "No worker class defined for job '$job'\n";

    # now call our job function
    my $class = "MogileFS::Worker::" . $class_suffix;
    my $worker = $class->new($psock);
    $worker->work;
    exit 0;
}

# given (job, pid), record that this worker is about to die
sub note_pending_death {
    my ($job, $pid) = @_;

    die "$job not defined in call to note_pending_death.\n"
        unless defined $jobs{$job};

    $todie{$pid} = 1;
    $jobs{$job}->[1]--;
}

# log stuff to syslog or the screen
sub log {
    # simple logging functionality
    if (! $daemonize) {
        # syslog acts like printf so we have to use printf and append a \n
        shift; # ignore the first parameter (info, warn, critical, etc)
        printf(shift(@_) . "\n", @_);
    } else {
        # just pass the parameters to syslog
        syslog(@_);
    }
}


# argument: a string to take as indicating the error that just happened.
sub error {
    if ($psock) {
        # we're a child, pass error to parent
        send_to_parent("error $_[0]");
    } else {
        # we're a parent, so just handle output of error
        Frontend->NoteError(\$_[0]);
        Mgd::log('debug', $_[0]);
    }
    return 0;
}

# copies a file from one Perlbal to another utilizing HTTP
sub http_copy {
    my ($sdevid, $ddevid, $fid) = @_;

    # handles setting unreachable magic; $error->(reachability, "message")
    my $error = sub {
        if ($_[0]) {
            send_to_parent("repl_unreachable $fid");

            # update database table
            Mgd::validate_dbh();
            my $dbh = Mgd::get_dbh();
            $dbh->do("REPLACE INTO unreachable_fids VALUES ($fid, UNIX_TIMESTAMP())");
        }
        return error($_[1]);
    };

    # get some information we'll need
    my $devs = Mgd::get_device_summary();
    my ($sdev, $ddev) = ($devs->{$sdevid}, $devs->{$ddevid});
    return error("Error: unable to get device information: source=$sdevid, destination=$ddevid, fid=$fid")
        unless ref $sdev && ref $ddev;
    my ($spath, $dpath) = (Mgd::make_http_path($sdevid, $fid),
                           Mgd::make_http_path($ddevid, $fid));
    my ($shost, $sport) = (Mgd::hostid_ip($sdev->{hostid}), Mgd::hostid_http_port($sdev->{hostid}));
    my ($dhost, $dport) = (Mgd::hostid_ip($ddev->{hostid}), Mgd::hostid_http_port($ddev->{hostid}));
    unless (defined $spath && defined $dpath && defined $shost && defined $dhost && $sport && $dport) {
        # show detailed information to find out what's not configured right
        error("Error: unable to replicate file fid=$fid from device id $sdevid to device id $ddevid");
        error("       http://$shost:$sport$spath -> http://$dhost:$dport$dpath");
        return 0;
    }

    # setup our pipe error handler, in case we get closed on
    my $pipe_closed = 0;
    local $SIG{PIPE} = sub { $pipe_closed = 1; };

    # okay, now get the file
    my $sock = IO::Socket::INET->new(PeerAddr => $shost, PeerPort => $sport, Timeout => 2)
        or return error("Unable to create socket to $shost:$sport for $spath");
    $sock->write("GET $spath HTTP/1.0\r\n\r\n");
    return error("Pipe closed retrieving $spath from $shost:$sport")
        if $pipe_closed;

    # we just want a content length
    my $clen;
    while (defined (my $line = <$sock>)) {
        $line =~ s/[\s\r\n]+$//;
        last unless length $line;
        if ($line =~ m!^HTTP/\d+\.\d+\s+(\d+)!) {
            # make sure we get a good response
            return $error->(1, "Error: Resource http://$shost:$sport$spath failed: HTTP $1")
                unless $1 >= 200 && $1 <= 299;
        }
        next unless $line =~ /^Content-length:\s*(\d+)\s*$/i;
        $clen = $1;
    }
    return $error->(1, "File $spath has a content-length of 0; unable to replicate")
        unless $clen;

    # open target for put
    my $dsock = IO::Socket::INET->new(PeerAddr => $dhost, PeerPort => $dport, Timeout => 2)
        or return error("Unable to create socket to $dhost:$dport for $dpath");
    $dsock->write("PUT $dpath HTTP/1.0\r\nContent-length: $clen\r\n\r\n")
        or return error("Unable to write data to $dpath on $dhost:$dport");
    return error("Pipe closed during write to $dpath on $dhost:$dport")
        if $pipe_closed;

    # now read data and print while we're reading.
    my ($data, $read, $written) = ('', 0, 0);
    while (!$pipe_closed && (my $bytes = $sock->read($data, $clen - $read))) {
        # now we've read in $bytes bytes
        $read += $bytes;
        my $wbytes = $dsock->send($data);
        $written += $wbytes;
        return error("Error: wrote $wbytes; expected to write $bytes; failed putting to $dpath")
            unless $wbytes == $bytes;
    }
    return error("Error: wrote $written bytes, expected to write $clen")
        unless $written == $clen;

    # now read in the response line (should be first line)
    my $line = <$dsock>;
    if ($line =~ m!^HTTP/\d+\.\d+\s+(\d+)!) {
        return 1 if $1 >= 200 && $1 <= 299;
        warn "Error: got a 404 in put: device not on host?: http://$dhost:$dport$dpath"
            if $1 == 404;
    } else {
        warn "Error: HTTP response line not recognized: $line";
    }
    return 0;
}

# replicates $fid if its devcount is less than $min.
sub replicate {
    my ($dbh, $fid, $min) = @_;

    my $lockname = "mgfs:fid:$fid:replicate";
    my $lock = $dbh->selectrow_array("SELECT GET_LOCK(?, 1)", undef,
                                     $lockname);
    return error("Unable to obtain lock $lockname")
        unless $lock;

    # hashref of devid -> $device_row_href  (where devid is alive)
    my $devs = Mgd::get_device_summary();
    return error("Device information from get_device_summary is empty")
        unless $devs && %$devs;

    # learn what devices this file is already on
    my $on_count = 0;
    my %on_host;     # hostid -> 1
    my @dead_devid;   # list of dead devids.  FIXME: do something with this?
    my @exist_devid;  # list of existing devids

    my $sth = $dbh->prepare("SELECT devid FROM file_on WHERE fid=?");
    $sth->execute($fid);
    die $dbh->errstr if $dbh->err;
    while (my ($devid) = $sth->fetchrow_array) {
        my $d = $devs->{$devid};
        unless ($d && $d->{status} =~ /^alive|readonly$/) {
            push @dead_devid, $devid;
            next;
        }
        $on_host{$d->{hostid}} = 1;
        $on_count++;
        push @exist_devid, $devid;
    }

    my $retunlock = sub {
        my $rv = shift;
        $dbh->selectrow_array("SELECT RELEASE_LOCK(?)", undef, $lockname);
        return $rv ? $rv : error($_[0]);
    };

    return $retunlock->(2) if $on_count >= $min;
    return $retunlock->(0, "Source is no longer available replicating $fid") if $on_count == 0;
    return $retunlock->(0, "No eligible devices available replicating $fid") if @exist_devid == 0;

    my $sdevid;

    while ($on_count < $min) {
        my $need = $min - $on_count;

        my @good_devids = Mgd::find_deviceid(
            random => 1,
            not_on_hosts => [ keys %on_host ],
            weight_by_free => 1,
        );

        # wasn't able to replicate enough?
        last unless @good_devids;

        my $ddevid = shift @good_devids;
        $sdevid ||= @exist_devid[int(rand(scalar @exist_devid))];

        my $rv = undef;
        if ($USE_HTTP) {
            $rv = http_copy($sdevid, $ddevid, $fid);
        } else {
            my $dst_path = $MOG_ROOT . "/" . make_path($ddevid, $fid);
            my $src_path = $MOG_ROOT . "/" . make_path($sdevid, $fid);
            $rv = File::Copy::copy($src_path, $dst_path);
        }

        return $retunlock->(0, "Copier failed replicating $fid") unless $rv;
        add_file_on($fid, $ddevid, 1);
        $on_count++;
    }

    return $retunlock->(1);
}

sub get_mindevcounts {
    # make sure we have good info
    Mgd::check_host_cache();
    my $host_ct = keys %Mgd::cache_host;

    # find the classes for each domainid (including domains without explict classes)
    my %min; # dmid -> classid -> mindevcount
    validate_dbh();
    my $dbh = get_dbh();
    my $sth = $dbh->prepare("SELECT d.dmid, c.classid, c.mindevcount ".
                            "FROM domain d LEFT JOIN class c ON d.dmid=c.dmid");
    $sth->execute;
    while (my ($dmid, $classid, $mct) = $sth->fetchrow_array) {
        $min{$dmid} ||= {};  # note the existence of this dmid

        # classid may be NULL (undef), in which case there are no classes defined
        # and we don't note the mindevcount (yet)
        $min{$dmid}{$classid} = int($host_ct < $mct ? $host_ct : $mct) if defined $classid;
    }


    # now iterate over %min again to set the implicit class
    foreach my $dmid (keys %min) {
        # each domain's classid=0, if not defined, has an implied mindevcount of $default_mindevcount
        # which most people will probably use.
        $min{$dmid}{0} = $host_ct < $default_mindevcount ? $host_ct : $default_mindevcount
            unless exists $min{$dmid}{0};
    }

    # return ref to hash
    return \%min;
}

#####################################################################
### S E R V E R   A P I   F U N C T I O N S
#####################################################################

# returns hashref of devid -> $device_row_href  (where devid is alive/down, but not dead)
# cached for 15 seconds.
use vars qw($cache_device_summary $cache_device_summary_time %cache_host $cache_host_time);

# general purpose device locator.  example:
#
# my $devid = Mgd::find_deviceid(
#     random => 1,              # get random device (else find first suitable)
#     min_free_space => 100,    # with at least 100MB free
#     weight_by_free => 1,      # find result weighted by free space
#     max_disk_age => 5,        # minutes of age the last usage report can be before we ignore the disk
#     not_on_hosts => [ 1, 2 ], # no devices on hosts 1 and 2
# );
#
# returns undef if no suitable device was found.  else, if you wanted an
# array will return an array of the suitable devices--if you want just a
# single item, you get just the first one found.
sub find_deviceid {
    my %opts = ( @_ );

    # copy down global minimum free space if not specified
    $opts{min_free_space} ||= $min_free_space;
    $opts{max_disk_age} ||= $max_disk_age;
    if ($opts{max_disk_age}) {
        $opts{max_disk_age} = time() - ($opts{max_disk_age} * 60);
    }

    # setup for iterating over devices
    my $devs = Mgd::get_device_summary();
    my @devids = keys %{$devs || {}};
    my $devcount = scalar(@devids);
    my $start = $opts{random} ? int(rand($devcount)) : 0;
    my %not_on_host = ( map { $_ => 1 } @{$opts{not_on_hosts} || []} );
    my $total_free = 0;

    # now find a device that matches what they want
    my @list;
    for (my $i = 0; $i < $devcount; $i++) {
        my $idx = ($i + $start) % $devcount;
        my $dev = $devs->{$devids[$idx]};

        # series of suitability checks
        next unless $dev->{status} eq 'alive';
        next if $not_on_host{$dev->{hostid}};
        next if $opts{max_disk_age} && $dev->{mb_asof} &&
                $dev->{mb_asof} < $opts{max_disk_age};
        next if $opts{min_free_space} && $dev->{mb_total} &&
                $dev->{mb_free} < $opts{min_free_space};

        # we get here, this is a suitable device
        push @list, $dev->{devid};
        $total_free += $dev->{mb_free};
    }

    # now we have a list ordered randomly, do free space weighting
    if ($opts{weight_by_free}) {
        my $rand = int(rand($total_free));
        my $cur = 0;

        foreach my $devid (@list) {
            $cur += $devs->{$devid}->{mb_free};
            return $devid if $cur >= $rand;
        }
    }

    # return whole list if wanting array, else just first item
    return wantarray ? @list : shift(@list);
}

# input:
#   given an array of arrayrefs of [ item, weight ], returns weighted randomized
#   list of items (without the weights, not arrayref; just list)
#
#   a weight of 0 means to exclude that item from the results list; i.e. it's not
#   ever used
#
# example:
#   my @items = weighted_list( [ 1, 10 ], [ 2, 20 ], [ 3, 0 ] );
#
#   returns (1, 2) or (2, 1) with the latter far more likely
sub weighted_list {
    my @list = grep { $_->[1] > 0 } @_;
    my @ret;

    my $sum = 0;
    $sum += $_->[1] foreach @list;

    my $getone = sub {
        return shift(@list)->[0]
            if scalar(@list) == 1;

        my $val = rand() * $sum;
        my $curval = 0;
        for (my $idx = 0; $idx < scalar(@list); $idx++) {
            my $item = $list[$idx];
            $curval += $item->[1];
            if ($curval >= $val) {
                my ($ret) = splice(@list, $idx, 1);
                $sum -= $item->[1];
                return $ret->[0];
            }
        }
    };

    push @ret, $getone->() while @list;
    return @ret;
}

sub get_device_summary {
    my $now = time;
    return $cache_device_summary if $cache_device_summary_time > $now - 15;

    my $dbh = get_dbh();

    # learn devices
    my %dev;  #
    my %hostdevs;  # hostid -> [ devid ]  (where devid is alive/down, but not dead)
    my $sth = $dbh->prepare("SELECT /*!40000 SQL_CACHE */ devid, hostid, mb_total, " .
                            "mb_used, mb_asof, status, weight FROM device");
    $sth->execute;
    $dev{$_->{devid}} = $_ while $_ = $sth->fetchrow_hashref;

    # now override device status with host status if the host status is less than the device status
    Mgd::check_host_cache();
    foreach my $devid (keys %dev) {
        # makes others have an easier time of finding devices by free space
        $dev{$devid}->{mb_free} = $dev{$devid}->{mb_total} - $dev{$devid}->{mb_used};

        my $host_status = $cache_host{$dev{$devid}->{hostid}}->{status};
        if ($dev{$devid}->{status} eq 'alive' && $host_status ne 'alive') {
            $dev{$devid}->{status} = $host_status;
        } elsif ($dev{$devid}->{status} eq 'down' && $host_status eq 'dead') {
            $dev{$devid}->{status} = $host_status;
        }
    }

    $cache_device_summary_time = $now;
    return $cache_device_summary = \%dev;
}

sub invalidate_device_cache {
    # so next time it's invalid and won't be used old
    $cache_device_summary_time = 0;
    $cache_device_summary = undef;
}

# FIXME: this should propogate to parent, and send messages down to
# query workers.  otherwise there's coherency issues between threads
# for a bit.
sub invalidate_host_cache {
    # so next time it's invalid and won't be used old
    $cache_host_time = 0;
    %cache_host = ();
}

sub check_host_cache {
    my $now = time;
    return if $cache_host_time > $now - 5;

    %cache_host = ();
    my $dbh = get_dbh();
    my $sth = $dbh->prepare("SELECT /*!40000 SQL_CACHE */ hostid, status, hostname, " .
                            "hostip, http_port, http_get_port, remoteroot, altip, altmask FROM host");
    $sth->execute;
    while (my $host = $sth->fetchrow_hashref) {
        $cache_host{$host->{hostid}} = $host;
        $cache_host{$host->{hostid}}->{mask} = Net::Netmask->new2($host->{altmask})
            if $host->{altip} && $host->{altmask};
    }
    $cache_host_time = $now;
}

sub key_filerow {
    my ($dbh, $dmid, $key) = @_;
    my $row = $dbh->selectrow_hashref("SELECT fid, dmid, dkey, length, classid, devcount ".
                                      "FROM file WHERE dmid=? AND dkey=?",
                                      undef, $dmid, $key);
    return $row;
}

# see if we should reduce the number of active children
sub job_needs_reduction {
    my $job = shift;
    return $jobs{$job}->[0] < $jobs{$job}->[1];
}

# given a file descriptor number and a timeout, wait for that descriptor to
# become readable; returns 0 or 1 on if it did or not
sub wait_for_readability {
    my ($fileno, $timeout) = @_;
    return 0 unless $fileno && $timeout;

    my $rin;
    vec($rin, $fileno, 1) = 1;
    my $nfound = select($rin, undef, undef, $timeout);

    # nfound can be undef or 0, both failures, or 1, a success
    return $nfound ? 1 : 0;
}

# get size of file, return 0 on error
sub get_file_size {
    my $path = shift;

    # quick case -- just a file on disk
    unless ($path =~ m!^http://([^:/]+)(?::(\d+))?(/.+)$!) {
        return -s "$Mgd::MOG_ROOT/$path"
    }
    my ($host, $port, $uri) = ($1, $2, $3);

    # don't sigpipe us
    local $SIG{'PIPE'} = "IGNORE" unless $FLAG_NOSIGNAL;

    # setup for sending size request to cached host
    my $req = "size $uri\r\n";
    my $reqlen = length $req;
    my $rv = 0;
    my $sock = $streamcache{$host};

    # sub to parse the response from $sock.  returns undef on error,
    # or otherwise the size of the $path in bytes.
    my $parse_response = sub {
        # give the socket 3 seconds to become readable
        unless (Mgd::wait_for_readability(fileno($sock), $node_timeout)) {
            close($sock);
            return undef;
        }

        # now we know there's readable data
        my $line = <$sock>;
        return undef unless defined $line;
        return undef unless $line =~ /^(\S+)\s+(-?\d+)/; # expected format: "uri size"
        return error("get_file_size() requested size of $path, got back size of $1 ($2 bytes)")
            if $1 ne $uri;
        return 0 if $2 < 0;   # backchannel sends back -1 on errors, which we need to map to 0
        return $2+0;
    };

    # try using the cached socket
    if ($sock) {
        $rv = send($sock, $req, $FLAG_NOSIGNAL);
        if ($!) {
            undef $streamcache{$host};
        } elsif ($rv != $reqlen) {
            return error("send() didn't return expected length ($rv, not $reqlen) for $path");
        } else {
            # success
            my $size = $parse_response->();
            return $size if defined $size;
        }
    }

    # try creating a connection to the stream
    unless ($rv) {
        $sock = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $MOGSTORED_STREAM_PORT, Timeout => 5);
        $streamcache{$host} = $sock;
        if ($sock) {
            $rv = send($sock, $req, $FLAG_NOSIGNAL);
            if ($!) {
                return error("error talking to mogstored stream ($path): $!");
            } elsif ($rv != $reqlen) {
                return error("send() didn't return expected length ($rv, not $reqlen) for $path");
            } else {
                # success
                my $size = $parse_response->();
                return $size if defined $size;
            }
        }
    }

    # failure case: use a HEAD request to get the size of the file
    my $sock = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $port, Timeout => 3)
        or return error("get_file_size() unable to contact mogstored for size of $path");
    $sock->write("HEAD $uri HTTP/1.0\r\n\r\n");
    my $first = <$sock>;
    return error("get_file_size()'s HEAD request wasn't a 200 OK") unless $first =~ m!^HTTP/1\.\d 200!;
    while (defined (my $line = <$sock>)) {
        last if $line eq "\r\n";
        if ($line =~ /^Content-length: (\d+)/i) {
            # success
            return $1+0;
        }
    }

    # no content length found?
    return error("get_file_size() found no content-length header in response for $path");
}

sub class_id {
    my ($dmid, $class) = @_;
    return undef unless $dmid > 0 && length $class;

    my $dbh = Mgd::get_dbh;
    my $classid = $dbh->selectrow_array
        ("SELECT classid FROM class WHERE dmid=? AND classname=?", undef, $dmid, $class)
            or return undef;
    return undef unless $classid;
    return $classid;
}

sub hostid_classes {
    my $dmid = shift;
    return undef unless $dmid > 0;

    my $dbh = Mgd::get_dbh;
    my $classes = $dbh->selectall_arrayref
        ("SELECT classid, classname, mindevcount FROM class WHERE dmid=?", undef, $dmid)
            or return undef;
    return undef unless $classes;

    my $res = {};
    foreach my $row (@$classes) {
        $res->{$row->[0]} = {
            classid => $row->[0],
            classname => $row->[1],
            mindevcount => $row->[2],
        };
    }
    return $res;
}

sub host_id {
    my $host = shift;
    return undef unless $host;

    Mgd::check_host_cache();

    foreach my $hostid (keys %Mgd::cache_host) {
        return $hostid
            if $Mgd::cache_host{$hostid}->{hostname} eq $host;
    }

    return undef;
}

sub domain_id {
    # check the cache for this item
    my $now = time();
    if ($domaincachetime + 5 < $now) {
        %domaincache = ();

        # now get updated list
        my $dbh = Mgd::get_dbh;
        my $domains = $dbh->selectall_arrayref('SELECT dmid, namespace FROM domain');
        foreach my $row (@{$domains || []}) {
            # namespace -> dmid
            $domaincache{$row->[1]} = $row->[0];
        }

        $domaincachetime = $now;
    }

    # just use cached version
    return $domaincache{$_[0]};
}

sub class_name {
    my ($dmid, $classid) = @_;
    return undef unless $dmid > 0 && length $classid;
    # FIXME: cache this

    # lookup class
    my $dbh = Mgd::get_dbh;
    my $classname = $dbh->selectrow_array
        ("SELECT classname FROM class WHERE dmid=? AND classid=?", undef, $dmid, $classid)
            or return undef;
    return undef unless $classname;
    return $classname;
}

sub domain_name {
    my $dmid = shift;
    # FIXME: cache this

    # lookup domain
    my $dbh = Mgd::get_dbh;
    my $namespace = $dbh->selectrow_array
        ("SELECT namespace FROM domain WHERE dmid=?", undef, $dmid);
    return $namespace;

}

sub hostid_name {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{hostname} : undef;
}

sub set_force_altzone {
    my $val = shift;
    $force_alt_zone = $val;
}

sub set_client_ip {
    my $ip = shift;
    $client_ip = $ip;
}

sub hostid_ip {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return undef unless $h;

    # if we have a client ip and an object for alt matching...
    if ($h->{mask} && $h->{altip} &&
            ($force_alt_zone || ($client_ip && $h->{altip} && $h->{mask}->match($client_ip)))) {
        return $h->{altip};
    } else {
        return $h->{hostip};
    }
}

sub hostid_http_port {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{http_port} : undef;
}

sub hostid_http_get_port {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{http_get_port} : undef;
}

sub make_http_path {
    my ($devid, $fid) = @_;

    my $dsum = get_device_summary();
    my $dinfo = $dsum->{$devid};
    return undef unless $dinfo;
    my $hostname = hostid_name($dinfo->{hostid});

    my $nfid = sprintf '%010d', $fid;
    my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

    return "/dev$devid/$b/$mmm/$ttt/$nfid.fid";
}

sub make_full_url {
    # set use_get_port to be true to specify to use the get port
    my ($devid, $fid, $use_get_port) = @_;

    # get some information we'll need
    my $devs = Mgd::get_device_summary();
    my $dev = $devs->{$devid} or return undef;
    my $path = Mgd::make_http_path($devid, $fid) or return undef;
    my $host = Mgd::hostid_ip($dev->{hostid}) or return undef;
    my $port = $use_get_port ? Mgd::hostid_http_get_port($dev->{hostid}) : undef;
    $port ||= Mgd::hostid_http_port($dev->{hostid}) or return undef;
    return "http://$host:$port$path";
}

# if given an HTTP URL, break it down into [ host, port, URI ], else
# returns undef
sub is_url {
    my $path = shift;
    if ($path =~ m!^http://(.+?)(?::(\d+))?(/.+)$!) {
        return [ $1, $2 || 80, $3 ];
    }
    return undef;
}

sub make_path {
    # jump out if we should be using HTTP stuff
    return Mgd::make_full_url(@_) if $USE_HTTP;

    my ($devid, $fid) = @_;

    my $dsum = get_device_summary();
    my $dinfo = $dsum->{$devid};
    return undef unless $dinfo;
    my $hostname = hostid_name($dinfo->{hostid});

    my $nfid = sprintf '%010d', $fid;
    my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

    my $path = "$hostname/dev$devid/$b/$mmm/$ttt/$nfid.fid";
    make_dirs( "$MOG_ROOT/$path" ) or return undef;

    return $path;
}

sub make_get_path {
    # the get path only changes for HTTP mode
    return Mgd::make_path(@_) unless $USE_HTTP;
    return Mgd::make_full_url(@_, 1);
}

sub make_dirs
{
    my $filename = shift;
    my $dir = File::Basename::dirname($filename);
    eval { File::Path::mkpath($dir, 0, 0775); };
    return $@ ? 0 : 1;
}

sub add_file_on {
    my ($fid, $devid, $no_lock) = @_;

    my $dbh = get_dbh() or return 0;

    my $rv = $dbh->do("INSERT IGNORE INTO file_on SET fid=?, devid=?",
                      undef, $fid, $devid);
    if ($rv > 0) {
        return update_fid_devcount($fid, $no_lock);
    } else {
        # was already on that device
        return 1;
    }
}

sub update_fid_devcount {
    my ($fid, $no_lock) = @_;

    my $dbh = get_dbh() or return 0;

    my $lockname = "mgfs:fid:$fid";
    unless ($no_lock) {
        my $lock = $dbh->selectrow_array("SELECT GET_LOCK(?, 10)", undef,
                                         $lockname);
        return 0 unless $lock;
    }
    my $ct = $dbh->selectrow_array("SELECT COUNT(*) FROM file_on WHERE fid=?",
                                   undef, $fid);

    $dbh->do("UPDATE file SET devcount=? WHERE fid=?", undef,
             $ct, $fid);

    unless ($no_lock) {
        $dbh->selectrow_array("SELECT RELEASE_LOCK(?)", undef, $lockname);
    }

    return 1;
}

sub randlist
{
    my @rlist = @_;
    my $size = scalar(@rlist);

    my $i;
    for ($i=0; $i<$size; $i++)
    {
        unshift @rlist, splice(@rlist, $i+int(rand()*($size-$i)), 1);
    }
    return @rlist;
}




#####################################################################
### W O R K E R C O N N   C L A S S
### This class maintains a connection to one of our various classes
### of workers.
#####################################################################
package WorkerConn;

use Danga::Socket ();
use base qw{Danga::Socket};

use fields qw{read_buf job pid cmd_buf reqid};

sub new {
    my WorkerConn $self = shift;
    $self = fields::new($self) unless ref $self;
    $self->SUPER::new( @_ );

    # mark as not a worker by default
    $self->{pid} = 0;
    $self->{reqid} = 0;
    $self->{job} = undef;
    $self->{cmd_buf} = [];

    return $self;
}

sub event_read {
    my WorkerConn $self = shift;

    my $bref = $self->read(1024);
    return $self->close() unless defined $bref;
    $self->{read_buf} .= $$bref;

    while ($self->{read_buf} =~ s/^(.+?)\r?\n//) {
        my $line = $1;
        if ($self->job eq 'queryworker' && (substr($line, 0, 5) ne 'error')) {
            Frontend->HandleQueryWorkerResponse($self, $line);
        } else {
            Frontend->HandleChildRequest($self, $line);
        }
    }
}

sub job {
    my WorkerConn $self = shift;
    return $self->{job} unless @_;
    return $self->{job} = shift;
}

sub pid {
    my WorkerConn $self = shift;
    return $self->{pid} unless @_;
    return $self->{pid} = shift;
}

sub event_hup { my $self = shift; $self->close; }

sub close {
    # mark us as being dead
    my WorkerConn $self = shift;
    Frontend->NoteDeadWorkerConn($self);
    $self->SUPER::close(@_);
}

sub enqueue_line {
    my WorkerConn $self = $_[0];
    return if $self->job eq 'queryworker'; # they don't use this queueing
    my $msg = "$_[1]\r\n";
    push @{$self->{cmd_buf}}, $msg;
}

sub drain_queue {
    my WorkerConn $worker = $_[0];
    foreach my $cmd (@{$worker->{cmd_buf}}) {
        $worker->write($cmd);
    }
    $worker->write(".\r\n");
    $worker->{cmd_buf} = [];
}


#####################################################################
### F R O N T E N D  C L A S S
### This class handles keeping lists of workers and clients and
### assigning them to eachother when things happen.  This is a purely
### event driven class.
#####################################################################
package Frontend;

# Mappings: fd => [ clientref, jobstring, starttime ]
# queues are just lists of Client class objects
# ChildrenByJob: job => { pid => $client }
# ErrorsTo: fid => Client
# RecentQueries: [ string, string, string, ... ]
# Stats: element => number
our ($IsChild, @QueryWorkerQueue, @ClientQueue, @RecentQueries,
     %Mappings, %ChildrenByJob, %ErrorsTo, %Stats);
$IsChild = 0;

# when a child is spawned, they'll have copies of all the data from the
# parent, but they don't need it.  this method is called when you want
# to indicate that this Frontend is running on a child and should clean.
sub SetAsChild {
    @QueryWorkerQueue = ();
    @ClientQueue = ();
    %Mappings = ();
    $IsChild = 1;
    %ErrorsTo = ();

    # and now kill off our event loop so that we don't waste time
    Danga::Socket->SetPostLoopCallback(sub { return 0; });
}

# called when a child has died.  a child is someone doing a job for us,
# but it might be a queryworker or any other type of job.  we just want
# to remove them from our list of children.  they're actually respawned
# by the make_new_child function elsewhere in Mgd.
sub NoteDeadChild {
    my $pid = $_[1];
    foreach my $job (keys %ChildrenByJob) {
        return if # bail out if we actually delete one
            delete $ChildrenByJob{$job}->{$pid};
    }
}

# called when a client dies.  clients are users, management or non.
# we just want to remove them from the error reporting interface, if
# they happen to be part of it.
sub NoteDeadClient {
    my $client = $_[1];
    delete $ErrorsTo{$client->{fd}};
}

# called when the error function in Mgd is called and we're in the parent,
# so it's pretty simple that basically we just spit it out to folks listening
# to errors
sub NoteError {
    return unless %ErrorsTo;

    my $msg = ":: ${$_[1]}\r\n";
    foreach my $client (values %ErrorsTo) {
        $client->write(\$msg);
    }
}

# take a new connection that we know is from one of our children, but
# we're not sure what type of child, so just set it in read mode until
# they tell us what they are
sub RegisterWorkerConn {
    my WorkerConn $worker = $_[1];
    $worker->watch_read(1);
}

# take a new worker and note that it's a worker and ready to be used
# for commands.  this is called when workers connect to the frontend.
sub RegisterQueryWorker {
    # basically take the worker, mark it as a worker, enqueue it,
    # and then try to process the outstanding queues
    my WorkerConn $worker = $_[1];
    Frontend->EnqueueQueryWorker($worker);
}

# puts a worker back in the queue, deleting any outstanding jobs in
# the mapping list for this fd.
sub EnqueueQueryWorker {
    # first arg is class, second is worker
    my WorkerConn $worker = $_[1];
    delete $Mappings{$worker->{fd}};

    # see if we need to kill off some workers
    if (Mgd::job_needs_reduction('queryworker')) {
        Mgd::error("Reducing queryworker headcount by 1.");
        Frontend->AskWorkerToDie($worker);
        return;
    }

    # must be okay, so put it in the queue
    push @QueryWorkerQueue, $worker;
    Frontend->ProcessQueues;
}

# if we need to kill off a worker, this function takes in the WorkerConn
# object, tells it to die, marks us as having requested its death, and decrements
# the count of running jobs.
sub AskWorkerToDie {
    my WorkerConn $worker = $_[1];
    $worker->write("shutdown\r\n");
    Mgd::note_pending_death($worker->job, $worker->pid);
}

# kill bored query workers so we can get down to the level requested.  this
# continues killing until we run out of folks to kill.
sub CullQueryWorkers {
    while (@QueryWorkerQueue && Mgd::job_needs_reduction('queryworker')) {
        my WorkerConn $worker = shift @QueryWorkerQueue;
        Frontend->AskWorkerToDie($worker);
    }
}

# called when we get a response from a worker.  this reenqueues the
# worker so it can handle another response as well as passes the answer
# back on to the client.
sub HandleQueryWorkerResponse {
    return Mgd::error("Frontend (Child) got worker response: $_[2]") if $IsChild;

    # got a response from a worker
    my WorkerConn $worker = $_[1];
    return unless $worker && $Mappings{$worker->{fd}};

    # get the client we're working with (if any)
    my $client = $Mappings{$worker->{fd}}->[0];

    # if we have no client, then we just got a standard message from
    # the queryworker and need to pass it up the line
    return Frontend->HandleChildRequest($worker, $_[2]) if !$client;

    # at this point it was a command response, but if the client has gone
    # away, just reenqueue this query worker
    return Frontend->EnqueueQueryWorker($worker) if $client->{closed};

    # <numeric id> [client-side time to complete] <response>
    my ($time, $id, $res);
    if ($_[2] =~ /^(\d+-\d+)\s+(\d+\.\d+)\s+(.+)$/) {
        # save time and response for use later
        ($id, $time, $res) = ($1, $2, $3);
    } elsif ($_[2] =~ /^(\d+-\d+)\s(.+)$/) {
        # didn't match, must be in a different format?
        ($id, $time, $res) = ($1, 'undef', $2);
    }

    # now, if it doesn't match
    unless ($id eq "$worker->{pid}-$worker->{reqid}") {
        Mgd::error("Worker responded with id $id, expected $worker->{pid}-$worker->{reqid}, killing");
        $client->close('worker_mismatch');
        return Frontend->AskWorkerToDie($worker);
    }

    # now time this interval and add to @RecentQueries
    my $tinterval = Time::HiRes::tv_interval([$Mappings{$worker->{fd}}->[2]]);
    push @RecentQueries, sprintf("%s %.4f %s", $Mappings{$worker->{fd}}->[1], $tinterval, $time);
    shift @RecentQueries if scalar(@RecentQueries) > 50;

    # send text to client, put worker back in queue
    $client->write("$res\r\n");
    Frontend->EnqueueQueryWorker($worker);
}

# called from various spots to empty the queues of available pairs.
sub ProcessQueues {
    return if $IsChild;

    # try to match up a client with a worker
    while (@QueryWorkerQueue && @ClientQueue) {
        # get client that isn't closed
        my $clref;
        while (@ClientQueue) {
            $clref = shift @ClientQueue;
            if (!defined $clref || $clref->[0]->{closed}) {
                $clref = undef;
                next;
            }

            # if we get here the client is valid
            last;
        }
        next unless $clref;

        # get worker and make sure it's not closed already
        my WorkerConn $worker = shift @QueryWorkerQueue;
        if (!defined $worker || $worker->{closed}) {
            unshift @ClientQueue, $clref;
            next;
        }

        # put in mapping and send data to worker
        push @$clref, Time::HiRes::gettimeofday();
        $Mappings{$worker->{fd}} = $clref;

        # increment our counter so we know what request counter this is going out
        $worker->{reqid}++;

        $worker->write("$worker->{pid}-$worker->{reqid} $clref->[1]\r\n");
        $worker->watch_read(1);
    }
}

# send short descriptions of commands we support to the user
sub SendHelp {
    my $client = $_[1];

    # not supported yet
    #my $whaton = $_[2];

    # send general purpose help
    $client->write(<<HELP);
Welcome to mogilefsd's built-in help system.  Available commands:

    !recent     Recently executed queries and how long they took.
    !queue      Queries that are pending execution.
    !stats      General stats on what we're up to.
    !watch      Observe errors/messages from children.
    !jobs       Outstanding job counts, desired level, and pids.
    !shutdown   IMMEDIATELY kill all of mogilefsd.  IMMEDIATELY.

    !replication
                See the replication status.  Output format:
                <domain> <class> <devcount> <files>

    !to <job class> <message>
                Send <message> to all workers of <job class>.
                Mostly used for debugging.

    !want <count> <job class>
                Alter the level of workers of this class desired.
                Example: !want 20 queryworker, !want 3 replicate.
                See !jobs for what jobs are available.

More to come...
.
HELP

}

# called when a client sends us text.  we just create a job for
# it and then call ProcessQueues.
sub HandleClientRequest {
    return Mgd::error("Frontend (Child) got request from client: $_[2]") if $IsChild;

    # if it's just 'help', 'h', '?', or something, do that
    if ((substr($_[2], 0, 1) eq '?') || ($_[2] eq 'help') || ($_[2] eq '')) {
        Frontend->SendHelp($_[1]);
        return;
    }

    # quick check to see if we the parent should handle this
    if (substr($_[2], 0, 1) eq '!') {
        my MogileFS::Connection::Client $client = $_[1];
        my ($cmd, $args) = ($_[2] =~ m/^!(.+?)(?:\s+(.+))?$/);

        my @out;
        if ($cmd =~ /^stats$/) {
            # print out some stats on the queues
            my $uptime = time - $Mgd::starttime;
            my $ccount = scalar(@ClientQueue);
            my $wcount = scalar(@QueryWorkerQueue);
            my $ipcount = scalar(keys %Mappings);
            push @out, "uptime $uptime",
                       "pending_queries $ccount",
                       "processing_queries $ipcount",
                       "bored_queryworkers $wcount",
                       map { "$_ $Stats{$_}" } sort keys %Stats;

        } elsif ($cmd =~ /^repl/) {
            Mgd::validate_dbh();
            my $dbh = Mgd::get_dbh();
            my $mdcs = Mgd::get_mindevcounts();
            foreach my $dmid (sort keys %$mdcs) {
                my $dmname = Mgd::domain_name($dmid);
                foreach my $classid (sort keys %{$mdcs->{$dmid}}) {
                    my $min = $mdcs->{$dmid}->{$classid};
                    next unless $min > 1;

                    my $classname = Mgd::class_name($dmid, $classid) || '_default';
                    foreach my $ct (1..$min-1) {
                        my $count = $dbh->selectrow_array('SELECT COUNT(*) FROM file WHERE dmid = ? AND classid = ? AND devcount = ?',
                                                          undef, $dmid, $classid, $ct);
                        push @out, "$dmname $classname $ct $count";
                    }
                }
            }

        } elsif ($cmd =~ /^shutdown/) {
            print "User requested shutdown: $args\n";
            kill 15, $$; # kill us, that kills our kids

        } elsif ($cmd =~ /^jobs/) {
            # dump out a list of running jobs and pids
            foreach my $job (sort keys %ChildrenByJob) {
                my $ct = scalar(keys %{$ChildrenByJob{$job}});
                push @out, "$job count $ct";
                push @out, "$job desired $jobs{$job}->[0]";
                push @out, "$job pids " . join(' ', sort { $a <=> $b } keys %{$ChildrenByJob{$job}});
            }

        } elsif ($cmd =~ /^want/) {
            # !want <count> <jobclass>
            # set the new desired staffing level for a class
            if ($args =~ /^(\d+)\s+(\S+)/) {
                my ($count, $job) = ($1, $2);

                # validate count
                $count = 0 if $count < 0;
                # FIXME ...add an upper limit?

                # now make sure it's a real job
                if (defined $jobs{$job}) {
                    $jobs{$job}->[0] = $count;
                    $Mgd::allkidsup = 0;
                    push @out, "Now desiring $count children doing '$job'.";

                    # try to clean out the queryworkers (if that's what we're doing?)
                    Frontend->CullQueryWorkers
                        if $job eq 'queryworker';
                } else {
                    my $classes = join(", ", sort keys %jobs);
                    push @out, "ERROR: Invalid class '$job'.  Valid classes: $classes";
                }
            } else {
                push @out, "ERROR: usage: !want <count> <jobclass>";
            }

        } elsif ($cmd =~ /^to/) {
            # !to <jobclass> <message>
            # sends <message> to all children of <jobclass>
            if ($args =~ /^(\S+)\s+(.+)/) {
                my $ct = Frontend->SendToChildrenByJob($1, $2);
                push @out, "Message sent to $ct children.";

            } else {
                push @out, "ERROR: usage: !to <jobclass> <message>";
            }

        } elsif ($cmd =~ /^queue/ || $cmd =~ /^pend/) {
            foreach my $clq (@ClientQueue) {
                push @out, $clq->[1];
            }

        } elsif ($cmd =~ /^watch/) {
            if (delete $ErrorsTo{$client->{fd}}) {
                push @out, "Removed you from watcher list.";
            } else {
                $ErrorsTo{$client->{fd}} = $client;
                push @out, "Added you to watcher list.";
            }

        } elsif ($cmd =~ /^recent/) {
            # show the most recent N queries
            push @out, @RecentQueries;

        } else {
            Frontend->SendHelp($client, $args);
        }
        $client->write(join("\r\n", @out) . "\r\n") if @out;
        $client->write(".\r\n");
        return;
    }

    # just push the input onto the client queue
    $Stats{queries}++;
    push @ClientQueue, [ $_[1], "cmd " . ($_[1]->peer_ip_string || '0.0.0.0') . " $_[2]" ];
    Frontend->ProcessQueues;
}

# a child has contacted us with some command/status/something.
sub HandleChildRequest {
    return Mgd::error("Frontend (Child) got request from child: $_[2]") if $IsChild;

    # if they have no job set, then their first line is what job they are
    # and not a command.  they also specify their pid, just so we know what
    # connection goes with what pid, in case it's ever useful information.
    my WorkerConn $child = $_[1];
    unless (defined $child->job) {
        my ($pid, $job) = ($_[2] =~ /^(\d+)\s+(.+)/);
        $child->job($job);
        $child->pid($pid);

        # now do any special case startup
        if ($job eq 'queryworker') {
            Frontend->RegisterQueryWorker($child);
        }

        # add to normal list
        $ChildrenByJob{$job}->{$child->pid} = $child;
        return;
    }

    # see if we should downsize this child
    my $check_job = sub {
        if (Mgd::job_needs_reduction($child->job)) {
            Mgd::error("Reducing headcount of " . $child->job . " job by 1.");
            Frontend->AskWorkerToDie($child);
        } else {
            $child->drain_queue;
        }
    };

    # at this point we've got a command of some sort
    my $cmd = $_[2];
    if ($cmd =~ /^error (.+)$/i) {
        # pass it on to our error handler, prefaced with the child's job
        Mgd::error("[" . $child->job . "(" . $child->pid . ")] $1");

    } elsif ($cmd =~ /^queue/) {
        # send out what we have queued up for it
        $child->drain_queue;

    } elsif ($cmd =~ /^request_orders/) {
        $check_job->();

    } elsif ($cmd =~ /^monitor_ping/) {
        $check_job->();

    } elsif ($cmd =~ /^reaper_ping/) {
        $check_job->();

    } elsif ($cmd =~ /^repl_ping/) {
        $check_job->();

    } elsif ($cmd =~ /^repl_unreachable (\d+)/) {
        # announce to the other replicators that this fid can't be reached, but note
        # that we don't actually drain the queue to the requestor, as the replicator
        # isn't in a place where it can accept a queue drain right now.
        Frontend->SendToChildrenByJob('replicate', "repl_unreachable $1", $child);

    } elsif ($cmd =~ /^repl_i_did (\d+)/) {
        my $fid = $1;

        # announce to the other replicators that this fid was done and then drain the
        # queue to this person.
        Frontend->SendToChildrenByJob('replicate', "repl_was_done $fid", $child);
        $check_job->();

    } else {
        # unknown command
        Mgd::error("Unknown command [$_[2]] from child; job=" . $child->job);
    }
}

# given a job class, and a message, send it to all children of that job.  returns
# the number of children the message was sent to.
# arguments: ( jobclass, message, [ child ] )
# if child is specified, the message will be sent to members of the job class that
# aren't that child.  so you can exclude the one that originated the message.
sub SendToChildrenByJob {
    my $childref = $ChildrenByJob{$_[1]};
    return 0 unless defined $childref && %$childref;
    my $msg = $_[2];

    foreach my $child (values %$childref) {
        # ignore the child specified as the third arg if one is sent
        next if defined $_[3] && $_[3] == $child;

        # send the message to this child
        $child->enqueue_line($msg);
    }
    return scalar(keys %$childref);
}

# called when we notice that a worker has bit it.  we might have to restart a
# job that they had been working on.
sub NoteDeadWorkerConn {
    return if $IsChild;

    # get parms and error check
    my WorkerConn $worker = $_[1];
    return unless $worker;

    # if there's a mapping for this worker's fd, they had a job that didn't get done
    if ($Mappings{$worker->{fd}}) {
        # unshift, since this one already went through the queue once
        unshift @ClientQueue, $Mappings{$worker->{fd}};
        delete $Mappings{$worker->{fd}};

        # now try to get it processing again
        Frontend->ProcessQueues;
    }
}

1;

# Local Variables:
# mode: perl
# c-basic-indent: 4
# indent-tabs-mode: nil
# End:
