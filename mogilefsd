#!/usr/bin/perl
#
# MogileFS daemon - HEAVILY UNDER CONSTRUCTION
#
# Copyright 2004, Danga Interactive
#
# Authors:
#   Brad Fitzpatrick <brad@danga.com>
#
# License:
#   undecided.
#

package Mgd;

# don't run as root
die "mogilefsd cannot be run as root\n"
    if $< == 0;

use strict;
use Getopt::Long;
use IO::Socket;
use Symbol;
use POSIX;
use DBI;
use DBD::mysql;
use File::Copy ();
use Carp;
use File::Basename ();
use File::Path ();


#####################################################################
### C O N F I G
#####################################################################

use vars qw($dbh $DEFAULT_CONFIG $DEFAULT_MOG_ROOT $MOG_ROOT $DEBUG $USE_HTTP);

$DEFAULT_CONFIG = "/etc/mogilefs/mogilefsd.conf";
$DEFAULT_MOG_ROOT = "/mnt/mogilefs";
$DEBUG = 0;

my (
    %cmdline,
    %cfgfile,
    $config,
    $skipconfig,
    $daemonize,
    $db_dsn,
    $db_user,
    $db_pass,
    $conf_port,
    $listener_jobs,
    $delete_jobs,
    $replicate_jobs,
    $mog_root,
   );

# Command-line options will override
Getopt::Long::Configure( "bundling" );
Getopt::Long::GetOptions(
    'c|config=s'    => \$config,
    's|skipconfig'  => \$skipconfig,
    'd|debug+'      => \$cmdline{debug},
    'D|daemon'      => \$cmdline{daemonize},
    'dsn=s'         => \$cmdline{db_dsn},
    'dbuser=s'      => \$cmdline{db_user},
    'dbpass=s'      => \$cmdline{db_pass},
    'r|mogroot=s'   => \$cmdline{mog_root},
    'p|confport=i'  => \$cmdline{conf_port},
    'l|listeners=i' => \$cmdline{listener_jobs},
    'no_http'       => \$cmdline{no_http},
);

$config = $DEFAULT_CONFIG if !$config && -r $DEFAULT_CONFIG;

# Read the config file if one was specified
if ( $config && !$skipconfig ) {
    open my $cf, "<$config" or die "open: $config: $!";

    my $configLine = qr{
        ^\s*                    # Leading space
        (\w+)                   # Key
        \s+ =? \s*              # space + optional equal + optional space
        (.+?)                   # Value
        \s*$                    # Trailing space
    }x;

    my $linecount = 0;
    while (defined( my $line = <$cf> )) {
        $linecount++;
        next if $line =~ m{^\s*(#.*)?$};
        die "Malformed config file (line $linecount)" unless $line =~ $configLine;

        my ( $key, $value ) = ( $1, $2 );
        print STDERR "Setting '$key' to '$value'\n" if $cmdline{debug};
        $cfgfile{ $key } = $value;
    }

    close $cf;
}

### FUNCTION: choose_value( $name, $default[, $boolean] )
sub choose_value ($$;$) {
    my ( $name, $default, $boolean ) = @_;

    if ( $boolean ) {
        return $cmdline{$name} if defined $cmdline{$name};
        return $cfgfile{$name} if defined $cfgfile{$name};
        return $default;
    }

    elsif ( !$boolean ) {
        return $cmdline{$name} || $cfgfile{ $name } || $default;
    }
}


# Fill in defaults for those values which were either loaded from config or
# specified on the command line. Command line takes precendence, then values in
# the config file, then the defaults.
$daemonize      = choose_value( 'daemonize', 0, 1 );
$db_dsn         = choose_value( 'db_dsn', "DBI:mysql:mogilefs" );
$db_user        = choose_value( 'db_user', "mogile" );
$db_pass        = choose_value( 'db_pass', "", 1 );
$conf_port      = choose_value( 'conf_port', 7001 );
$MOG_ROOT       = choose_value( 'mog_root', $DEFAULT_MOG_ROOT );
$listener_jobs  = choose_value( 'listener_jobs', 20 );
$delete_jobs    = choose_value( 'delete_jobs', 1 );
$replicate_jobs = choose_value( 'replicate_jobs', 1 );
$DEBUG          = choose_value( 'debug', 0, 1 );
$USE_HTTP       = ! choose_value( 'no_http', 0, 1);
print "USE_HTTP: $USE_HTTP\n";


#####################################################################
### D A E M O N   F U N C T I O N S
#####################################################################

daemonize() if $daemonize;

# establish SERVER socket, bind and listen.
my $server = IO::Socket::INET->new(LocalPort => $conf_port,
                                   Type      => SOCK_STREAM,
                                   Proto     => 'tcp',
                                   Blocking  => 1,
                                   Reuse     => 1,
                                   Listen    => 10 )
    or die "Error creating socket: $@\n";

# keep track of what all child pids are doing, and what jobs are being
# satisifed.
my %child  = ();    # pids -> job
my %jobs   = ();    # jobname -> [ min, current ]

# FIXME: make these configurable (and client_listen will use IO::Epoll or
# something in the future, maybe IO::Multiplex)
$jobs{'client_listen'} = [ $listener_jobs, 0 ];
$jobs{'delete'} = [ $delete_jobs, 0 ];
$jobs{'replicate'} = [ $replicate_jobs, 0 ];

sub validate_dbh {
    return unless $dbh;
    my $id = $dbh->selectrow_array("SELECT CONNECTION_ID()");
    if (! $id) {
        # handle's dead.  don't use it.  (MySQL-ism above)
        undef $dbh;
    }
}

sub get_dbh {
    return $dbh ||= DBI->connect($db_dsn, $db_user, $db_pass);
}

# Install signal handlers.
$SIG{TERM}  = sub {
    print STDERR scalar keys %child, " children to kill.\n" if $DEBUG;
    my $count = kill( 'TERM' => keys %child );
    print STDERR "Sent SIGTERM to $count children.\n" if $DEBUG;
    exit 0;
};
$SIG{INT}  = sub {
    print STDERR scalar keys %child, " children to kill.\n" if $DEBUG;
    my $count = kill( 'INT' => keys %child );
    print STDERR "Sent SIGINT to $count children.\n" if $DEBUG;
    exit 0;
};


# Keep jobs alive
while (1) {
    my $pid = wait;

    # when a child dies, figure out what it was doing
    # and note that job has one less worker
    my $job;
    if ($pid > -1 && ($job = delete $child{$pid})) {
        print "Child $pid died: $?\n";

        if (my $jobstat = $jobs{$job}) {
            $jobstat->[1]--;
        }
    }

    # foreach job, fork enough children
    while (my ($job, $jobstat) = each %jobs) {
        my $need = $jobstat->[0] - $jobstat->[1];
        if ($need > 0) {
            print "Job $job has only $jobstat->[1], wants $jobstat->[0], making $need.\n"
                if $DEBUG;
            for (1..$need) {
                my $cpid = make_new_child($job);
                $child{$cpid} = $job;
                $jobstat->[1]++;
            }
        }
    }

}

sub daemonize {
    my($pid, $sess_id, $i);

    ## Fork and exit parent
    if ($pid = fork) { exit 0; }

    ## Detach ourselves from the terminal
    croak "Cannot detach from controlling terminal"
        unless $sess_id = POSIX::setsid();

    ## Prevent possibility of acquiring a controling terminal
    $SIG{'HUP'} = 'IGNORE';
    if ($pid = fork) { exit 0; }

    ## Change working directory
    chdir "/";

    ## Clear file creation mask
    umask 0;

    print STDERR "Daemon running as pid $$.\n" if $DEBUG;

    ## Close open file descriptors
    close(STDIN);
    close(STDOUT);
    close(STDERR);

    ## Reopen stderr, stdout, stdin to /dev/null
    if ( $DEBUG ) {
        open(STDIN,  "+>/tmp/mogilefsd.log");
    } else {
        open(STDIN,  "+>/dev/null");
    }
    open(STDOUT, "+>&STDIN");
    open(STDERR, "+>&STDIN");
}

sub make_new_child {
    my $job = shift;

    my $pid;
    my $sigset;

    # block signal for fork
    $sigset = POSIX::SigSet->new(SIGINT);
    sigprocmask(SIG_BLOCK, $sigset)
        or die "Can't block SIGINT for fork: $!\n";

    die "fork: $!" unless defined ($pid = fork);

    if ($pid) {
        sigprocmask(SIG_UNBLOCK, $sigset)
            or die "Can't unblock SIGINT for fork: $!\n";
        return $pid;
    }

    $SIG{INT} = 'DEFAULT';

    # unblock signals
    sigprocmask(SIG_UNBLOCK, $sigset)
        or die "Can't unblock SIGINT for fork: $!\n";

    no strict 'refs';
    my $job_handler = *{"job_$job"}{CODE};
    $job_handler->($$);
    exit;
}

sub job_delete {

  PASS:
    while (1) {
        sleep 10;
        validate_dbh();
        my $dbh = get_dbh();

        my %dev_down;  # devid -> 1 (when device times out due to EIO)

        my $LIMIT = 500;
        while (1) {
            my $delmap = $dbh->selectall_arrayref("SELECT fd.fid, fo.devid ".
                                                  "FROM file_to_delete fd LEFT JOIN file_on fo ON fd.fid=fo.fid ".
                                                  "LIMIT $LIMIT ");
            my $count = $delmap ? scalar @$delmap : 0;
            next PASS unless $count;

            my %done;  # fid -> 1 (when fid is deleted from all devices)

            foreach my $dm (@$delmap) {
                my ($fid, $devid) = @$dm;

                # if no device is returned from the query above, that
                # means there are no file_on rows for it, and we can consider
                # it now deleted.
                unless ($devid) {
                    $done{$fid} = 1;
                    next;
                }

                # don't try to delete from this device if we earlier
                # found it to be timing out with EIO
                next if $dev_down{$devid};

                my $path = make_path($devid, $fid);
                my $rv = 0;
                if (my $urlref = Mgd::is_url($path)) {
                    # hit up the server and delete it
                    my $sock = IO::Socket::INET->new(PeerAddr => $urlref->[0],
                                                     PeerPort => $urlref->[1],
                                                     Timeout => 2);
                    unless ($sock) {
                        # timeout or something, mark this device as down for now and move on
                        $dev_down{$devid} = 1;
                        next;
                    }
                    
                    # send delete request
                    print "Sending delete for $path\n" if $Mgd::DEBUG >= 2;
                    print $sock "DELETE $urlref->[2] HTTP/1.0\r\n\r\n";
                    my $response = <$sock>;
                    if ($response =~ m!^HTTP/\d+\.\d+\s+(\d+)!) {
                        if (($1 >= 200 && $1 <= 299) || $1 == 404) {
                            # effectively means all went well
                            $rv = 1;
                        } else {
                            # remote file system error?  mark node as down
                            warn "Error: unlink failure: $path: $1\n";
                            $dev_down{$devid} = 1;
                            next;
                        }
                    } else {
                        warn "Error: unknown response line: $response\n";
                    }
                } else {
                    # do normal unlink
                    $rv = unlink "$Mgd::MOG_ROOT/$path";
                }

                # device is timing out.  take note of it and
                # continue dealing with other deletes
                if (! $rv && $! == EIO) {
                    $dev_down{$devid} = 1;
                    next;
                }

                # if we deleted it, or it didn't exist, consider it
                # deleted.
                if ($rv || $! == ENOENT) {
                    $dbh->do("DELETE FROM file_on WHERE fid=? AND devid=?",
                             undef, $fid, $devid);
                }
            }

            if (%done) {
                my $in = join(',', keys %done);
                $dbh->do("DELETE FROM file_to_delete WHERE fid IN ($in)");
            }

            next PASS if $count < $LIMIT;
        }

    }
}

# copies a file from one Perlbal to another utilizing HTTP
sub http_copy {
    my ($sdevid, $ddevid, $fid) = @_;

    # get some information we'll need
    my $devs = Mgd::get_device_summary();
    my ($sdev, $ddev) = ($devs->{$sdevid}, $devs->{$ddevid});
    unless (ref $sdev && ref $ddev) {
        warn "Error: unable to get device information: source=$sdevid, destination=$ddevid, fid=$fid\n";
        return 0;
    }
    my ($spath, $dpath) = (Mgd::make_http_path($sdevid, $fid),
                           Mgd::make_http_path($ddevid, $fid));
    my ($shost, $sport) = (Mgd::hostid_ip($sdev->{hostid}), Mgd::hostid_http_port($sdev->{hostid}));
    my ($dhost, $dport) = (Mgd::hostid_ip($ddev->{hostid}), Mgd::hostid_http_port($ddev->{hostid}));
    unless (defined $spath && defined $dpath && defined $shost && defined $dhost && $sport && $dport) {
        # show detailed information to find out what's not configured right
        warn "Error: unable to replicate file fid=$fid from device id $sdevid to device id $ddevid\n";
        warn "       http://$shost:$sport$spath -> http://$dhost:$dport$dpath\n";
        return 0;
    }
    print "http://$shost:$sport$spath -> http://$dhost:$dport$dpath\n" if $Mgd::DEBUG >= 2;

    # setup our pipe error handler, in case we get closed on
    my $pipe_closed = 0;
    local $SIG{PIPE} = sub { $pipe_closed = 1; };

    # okay, now get the file
    my $sock = IO::Socket::INET->new(PeerAddr => $shost, PeerPort => $sport, Timeout => 2)
        or return 0;
    print $sock "GET $spath HTTP/1.0\r\n\r\n";
    return 0 if $pipe_closed;

    # we just want a content length
    my $clen;
    while (defined (my $line = <$sock>)) {
        $line =~ s/[\s\r\n]+$//;
        last unless length $line;
        if ($line =~ m!^HTTP/\d+\.\d+\s+(\d+)!) {
            # make sure we get a good response
            unless ($1 >= 200 && $1 <= 299) {
                warn "Error: Resource http://$shost:$sport$spath failed: HTTP $1\n";
                return 0;
            }
        }
        next unless $line =~ /^Content-length:\s*(\d+)\s*$/i;
        $clen = $1;
    }
    return 0 unless $clen;

    # open target for put
    my $dsock = IO::Socket::INET->new(PeerAddr => $dhost, PeerPort => $dport, Timeout => 2) or return 0;
    $dsock->write("PUT $dpath HTTP/1.0\r\nContent-length: $clen\r\n\r\n") or return 0;
    return 0 if $pipe_closed;

    # now read data and print while we're reading
    my ($data, $read) = ('', 0);
    while (!$pipe_closed && (my $bytes = read($sock, $data, $clen - $read))) {
        $read += $bytes;
        last unless $dsock->write($data);
    }

    # now read in the response line (should be first line)
    my $line = <$dsock>;
    if ($line =~ m!^HTTP/\d+\.\d+\s+(\d+)!) {
        return 1 if $1 >= 200 && $1 <= 299;
        warn "Error: got a 404 in put: device not on host?: http://$dhost:$dport$dpath" if $1 == 404;
    } else {
        warn "Error: HTTP response line not recognized: $line";
    }
    return 0;
}

# replicates $fid if its devcount is less than $min.
sub replicate {
    my ($dbh, $fid, $min) = @_;

    print "Replicating: $fid (need $min)\n" if $Mgd::DEBUG >= 2;

    my $lockname = "mgfs:fid:$fid:replicate";
    my $lock = $dbh->selectrow_array("SELECT GET_LOCK(?, 1)", undef,
                                     $lockname);
    return 0 unless $lock;

    # hashref of devid -> $device_row_href  (where devid is alive)
    my $devs = Mgd::get_device_summary();
    return 0 unless $devs && %$devs;

    # learn what devices this file is already on
    my $on_count = 0;
    my %on_host;     # hostid -> 1
    my @dead_devid;   # list of dead devids
    my @exist_devid;  # list of existing devids

    my $sth = $dbh->prepare("SELECT devid FROM file_on WHERE fid=?");
    $sth->execute($fid);
    die $dbh->errstr if $dbh->err;
    while (my ($devid) = $sth->fetchrow_array) {
        my $d = $devs->{$devid};
        unless ($d) {
            push @dead_devid, $devid;
            next;
        }
        $on_host{$d->{hostid}} = 1;
        $on_count++;
        push @exist_devid, $devid;
    }

    my $retunlock = sub {
        my $rv = shift;
        $dbh->selectrow_array("SELECT RELEASE_LOCK(?)", undef, $lockname);
        return $rv;
    };

    return $retunlock->(1) if $on_count >= $min;
    return $retunlock->(0) if $on_count == 0;
    return $retunlock->(0) if @exist_devid == 0;

    my $sdevid;

    while ($on_count < $min) {
        my $need = $min - $on_count;

        my @good_devids = randlist(grep {
            $devs->{$_}{status} eq 'alive' && ! $on_host{$devs->{$_}{hostid}}
        } keys %$devs);

        # wasn't able to replicate enough?
        last unless @good_devids;

        my $ddevid = shift @good_devids;
        $sdevid ||= @exist_devid[int(rand(scalar @exist_devid))];

        my $rv = undef;
        if ($USE_HTTP) {
            $rv = http_copy($sdevid, $ddevid, $fid);
        } else {
            my $dst_path = $MOG_ROOT . "/" . make_path($ddevid, $fid);
            my $src_path = $MOG_ROOT . "/" . make_path($sdevid, $fid);
            $rv = File::Copy::copy($src_path, $dst_path);
        }

        return $retunlock->(0) unless $rv;
        add_file_on($fid, $ddevid, 1);
        $on_count++;
    }

    return $retunlock->(1);
}

sub job_replicate {
    while (1) {
        sleep 2;
        validate_dbh();
        my $dbh = get_dbh() or return 0;

        # find the classes for each domainid (including domains without explict classes)
        my %min; # dmid -> classid -> mindevcount
        my $sth = $dbh->prepare("SELECT d.dmid, c.classid, c.mindevcount ".
                                "FROM domain d LEFT JOIN class c ON d.dmid=c.dmid");
        $sth->execute;
        while (my ($dmid, $classid, $mct) = $sth->fetchrow_array) {
            $min{$dmid} ||= {};  # note the existence of this dmid

            # classid may be NULL (undef), in which case there are no classes defined
            # and we don't note the mindevcount (yet)
            $min{$dmid}{$classid} = int($mct) if defined $classid;
        }

        # iterate through each domain, replicating its contents
        foreach my $dmid (keys %min) {
            # each domain's classid=0, if not defined, has an implied mindevcount of 2,
            # which most people will probably use.
            $min{$dmid}{0} = 2 unless exists $min{$dmid}{0};

            # iterate through each class, including the implicit class 0
            while (my ($classid, $min) = each %{$min{$dmid}}) {

                print "Checking replication for dmid=$dmid, classid=$classid, min=$min\n" if $Mgd::DEBUG >= 1;

                my $LIMIT = 1000;
                while (1) {
                    my $fids = $dbh->selectcol_arrayref("SELECT fid FROM file WHERE dmid=? AND classid=? ".
                                                        "AND devcount>0 AND devcount<? AND length IS NOT NULL ".
                                                        "LIMIT $LIMIT", undef, $dmid, $classid, $min);
                    die $dbh->errstr if $dbh->err;
                    my $count = $fids ? scalar @$fids : 0;
                    print "  found $count for dmid=$dmid/classid=$classid/min=$min\n" if $Mgd::DEBUG >= 1;
                    last unless $count;
                    my $fixed = 0;

                    # randomize the list so multiple daemons/threads working on
                    # replicate at the same time don't all fight over the
                    # same fids to move
                    my @rand_finds = randlist(@$fids);

                    print "Need to replicate: $dmid/$classid: @$fids\n" if $Mgd::DEBUG >= 2;
                    foreach my $fid (@$fids) {
                        $fixed++ if replicate($dbh, $fid, $min);
                    }

                    last unless $count == $LIMIT || $fixed != $count;
                }

            }
        }
    }
}

sub job_client_listen {
    Client->DebugLevel( 3 );

    my $accept_handler = sub {
        my $csock = $server->accept();
        printf( "Listen child making a Client for %d.\n", fileno($csock) )
            if $DEBUG >= 2;
        validate_dbh();
        my $client = Client->new($csock);
        printf( "Client is %s\n", $client ) if $DEBUG >= 2;
        $client->watch_read(1);
    };

    Client->OtherFds( fileno($server) => $accept_handler );

    eval {
        print( "Starting event loop for client_listen job on pid $$.\n" ) if $DEBUG;
        Client->EventLoop();
    };

    if ( $@ ) { print STDERR "ERR: client_listen: $@\n" }
}


#####################################################################
### S E R V E R   A P I   F U N C T I O N S
#####################################################################

# returns hashref of devid -> $device_row_href  (where devid is alive/down, but not dead)
# cached for 15 seconds.
use vars qw($cache_device_summary $cache_device_summary_time %cache_host $cache_host_time);

sub get_device_summary {
    my $now = time;
    return $cache_device_summary if $cache_device_summary_time > $now - 15;

    my $dbh = get_dbh();

    # learn devices
    my %dev;  #
    my %hostdevs;  # hostid -> [ devid ]  (where devid is alive/down, but not dead)
    my $sth = $dbh->prepare("SELECT devid, hostid, mb_total, mb_used, status ".
                            "FROM device ".
                            "WHERE status IN ('alive', 'down')");
    $sth->execute;
    $dev{$_->{devid}} = $_ while $_ = $sth->fetchrow_hashref;

    $cache_device_summary_time = $now;
    return $cache_device_summary = \%dev;
}

sub check_host_cache {
    my $now = time;
    return if $cache_host_time > $now - 10;

    %cache_host = ();
    my $dbh = get_dbh();
    my $sth = $dbh->prepare("SELECT hostid, status, hostname, hostip, http_port, remoteroot FROM host");
    $sth->execute;
    $cache_host{$_->{hostid}} = $_ while $_ = $sth->fetchrow_hashref;
}

sub key_filerow {
    my ($dbh, $dmid, $key) = @_;
    my $row = $dbh->selectrow_hashref("SELECT fid, dmid, dkey, length, classid, devcount ".
                                      "FROM file WHERE dmid=? AND dkey=?",
                                      undef, $dmid, $key);
    return $row;
}

# get size of file, return 0 on error
sub get_file_size {
    my $path = shift;

    # quick case -- just a file on disk
    unless ($path =~ m!^http://(.+?)(/.+)$!) {
        return -s "$Mgd::MOG_ROOT/$path"
    }

    # URL; use a HEAD request to get the size of the file
    my $sock = IO::Socket::INET->new(PeerAddr => $1, Timeout => 2)
        or return 0;
    print $sock "HEAD $2 HTTP/1.0\r\n\r\n";
    while (defined (my $line = <$sock>)) {
        if ($line =~ /^Content-length: (\d+)/i) {
            return $1+0;
        }
    }

    # no content length found?
    return 0;
}

sub domain_id {
    my $domain = shift;
    # FIXME: cache this

    my $dbh = Mgd::get_dbh;
    # lookup domain
    my $dmid = $dbh->selectrow_array("SELECT dmid FROM domain WHERE namespace=?",
                                     undef, $domain);
    return $dmid;
}

sub hostid_name {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{hostname} : undef;
}

sub hostid_ip {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{hostip} : undef;
}

sub hostid_http_port {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{http_port} : undef;
}

sub make_http_path {
    my ($devid, $fid) = @_;

    my $dsum = get_device_summary();
    my $dinfo = $dsum->{$devid};
    return undef unless $dinfo;
    my $hostname = hostid_name($dinfo->{hostid});

    my $nfid = sprintf '%010d', $fid;
    my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

    return "/dev$devid/$b/$mmm/$ttt/$nfid.fid";
}

sub make_full_url {
    my ($devid, $fid) = @_;

    # get some information we'll need
    my $devs = Mgd::get_device_summary();
    my $dev = $devs->{$devid} or return undef;
    my $path = Mgd::make_http_path($devid, $fid) or return undef;
    my $host = Mgd::hostid_ip($dev->{hostid}) or return undef;
    my $port = Mgd::hostid_http_port($dev->{hostid}) or return undef;
    return "http://$host:$port$path";
}

# if given an HTTP URL, break it down into [ host, port, URI ], else
# returns undef
sub is_url {
    my $path = shift;
    if ($path =~ m!^http://(.+?)(?::(\d+))?(/.+)$!) {
        return [ $1, $2 || 80, $3 ];
    }
    return undef;
}

sub make_path {
    # jump out if we should be using HTTP stuff
    return Mgd::make_full_url(@_) if $USE_HTTP;
    
    my ($devid, $fid) = @_;

    my $dsum = get_device_summary();
    my $dinfo = $dsum->{$devid};
    return undef unless $dinfo;
    my $hostname = hostid_name($dinfo->{hostid});

    my $nfid = sprintf '%010d', $fid;
    my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

    my $path = "$hostname/dev$devid/$b/$mmm/$ttt/$nfid.fid";
    make_dirs( "$MOG_ROOT/$path" ) or return undef;

    return $path;
}

sub make_dirs
{
    my $filename = shift;
    my $dir = File::Basename::dirname($filename);
    eval { File::Path::mkpath($dir, 0, 0775); };
    return $@ ? 0 : 1;
}

sub add_file_on {
    my ($fid, $devid, $no_lock) = @_;

    my $dbh = get_dbh() or return 0;

    my $rv = $dbh->do("INSERT IGNORE INTO file_on SET fid=?, devid=?",
                      undef, $fid, $devid);
    if ($rv > 0) {
        return update_fid_devcount($fid, $no_lock);
    } else {
        # was already on that device
        return 1;
    }
}

sub update_fid_devcount {
    my ($fid, $no_lock) = @_;

    my $dbh = get_dbh() or return 0;

    my $lockname = "mgfs:fid:$fid";
    unless ($no_lock) {
        my $lock = $dbh->selectrow_array("SELECT GET_LOCK(?, 10)", undef,
                                         $lockname);
        return 0 unless $lock;
    }
    my $ct = $dbh->selectrow_array("SELECT COUNT(*) FROM file_on WHERE fid=?",
                                   undef, $fid);

    $dbh->do("UPDATE file SET devcount=? WHERE fid=?", undef,
             $ct, $fid);

    unless ($no_lock) {
        $dbh->selectrow_array("SELECT RELEASE_LOCK(?)", undef, $lockname);
    }

    return 1;
}

sub randlist
{
    my @rlist = @_;
    my $size = scalar(@rlist);

    my $i;
    for ($i=0; $i<$size; $i++)
    {
        unshift @rlist, splice(@rlist, $i+int(rand()*($size-$i)), 1);
    }
    return @rlist;
}


#####################################################################
### C L I E N T   C L A S S
#####################################################################
package Client;

use Danga::Socket ();
use base qw{Danga::Socket};

use fields qw{read_buf};

sub new {
    my Client $self = shift;
    $self = fields::new($self) unless ref $self;
    $self->SUPER::new( @_ );

    $self->debugmsg( 3, "New client for %d running.", $self->{fd} );
    return $self;
}

# Client
sub event_read {
    my $self = shift;
    $self->debugmsg( 3, "Read event on %d.", $self->{fd} );

    my $bref = $self->read(1024);
    return $self->close() unless defined $bref;
    $self->{read_buf} .= $$bref;

    if ($self->{read_buf} =~ s/^(.+?)\r?\n//) {
        my $line = $1;
        $self->process_line( $line );
    }
}

# Client
sub event_err {  my $self = shift; $self->close; }
sub event_hup {  my $self = shift; $self->close; }


sub process_line {
    my Client $self = shift;
    my $line = shift;

    if ($line =~ /^(\w+)\s*(.*)/) {
        my ($cmd, $args) = ($1, $2);
        $cmd = lc($cmd);

        no strict 'refs';
        my $cmd_handler = *{"cmd_$cmd"}{CODE};
        if ($cmd_handler) {
            my $args = decode_url_args(\$args);
            $cmd_handler->($self, $args);
            next;
        }
    }

    return $self->err_line('unknown_command');
}

# returns 0 on error, or dmid of domain
sub check_domain {
    my Client $self = shift;
    my $args = shift;

    return $self->err_line("no_domain") unless length($args->{domain});

    # validate domain
    my $dmid = Mgd::domain_id($args->{domain}) or
        return $self->err_line("unreg_domain");

    return $dmid;
}

sub cmd_create_open {
    my Client $self = shift;
    my $args = shift;

    # validate parameters
    my $dmid = $self->check_domain($args) or return 0;
    my $key = $args->{key} || "";

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");

    # figure out what classid this file is for
    my $class = $args->{class};
    my $classid = 0;
    if (length($class)) {
        # TODO: cache this
        $classid = $dbh->selectrow_array("SELECT classid FROM class ".
                                         "WHERE dmid=? AND classname=?",
                                         undef, $dmid, $class)
            or return $self->err_line("unreg_class");
    }

    # setup the new mapping
    $dbh->do("INSERT INTO tempfile SET ".
             " fid=NULL, dmid=?, dkey=?, classid=?",
             undef, $dmid, $key, $classid);
    return undef if $dbh->err;
    my $fid = $dbh->{mysql_insertid};  # FIXME: mysql-ism
    return undef unless $fid > 0;

    # find a device to put this file on that has 100Mb free.
    # FIXME: make this use get_device_summary, removing this SQL:
    my $devids = $dbh->selectcol_arrayref("SELECT devid FROM device ".
                                          "WHERE status='alive' AND (mb_used IS NULL ".
                                          "   OR (mb_total-mb_used > 100))");
    my $count = $devids ? @$devids : 0;
    return $self->err_line("no_devices") unless $count;

    # pick a random alive device
    my $devid = $devids->[int(rand($count))];

    # FIXME: verify the path is good, and try alt device otherwise
    my $path = Mgd::make_path($devid, $fid);

    # make a note that this file will be going here, so if it's
    # partially written and aborted, or closed, the cleanup
    # process will know what to cleanup
    $dbh->do("INSERT IGNORE INTO file_on SET fid=?, devid=?",
             undef, $fid, $devid);

    return $self->ok_line({
        fid => $fid,
        devid => $devid,
        path => $path,
    });
}

sub cmd_create_close {
    my Client $self = shift;
    my $args = shift;

    # validate parameters
    my $dmid = $self->check_domain($args) or return 0;
    my $key = $args->{key};

    my $fid = $args->{fid} or return $self->err_line("no_fid");
    my $devid = $args->{devid} or return $self->err_line("no_devid");
    my $path = $args->{path} or return $self->err_line("no_path");

    # is the provided path what we'd expect for this fid/devid?
    return $self->err_line("bogus_args")
        unless $path eq Mgd::make_path($devid, $fid);

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");

    # find the temp file we're closing and making real
    my $trow = $dbh->selectrow_hashref("SELECT classid, dmid, dkey ".
                                       "FROM tempfile WHERE fid=?",
                                       undef, $fid);
    return $self->err_line("no_temp_file") unless $trow;

    # if a temp file is closed without a provided-key, that means to
    # delete it.
    unless (length($key)) {
        # add to to-delete list
        $dbh->do("REPLACE INTO file_to_delete SET fid=?", undef, $fid);
        $dbh->do("DELETE FROM tempfile WHERE fid=?", undef, $fid);
        return $self->ok_line;
    }

    # see if we have a fid for this key already
    my $old_file = Mgd::key_filerow($dbh, $dmid, $key);
    if ($old_file) {
        # add to to-delete list
        $dbh->do("REPLACE INTO file_to_delete SET fid=?", undef, $old_file->{fid});
        $dbh->do("DELETE FROM file WHERE fid=?", undef, $old_file->{fid});
    }

    # get size of file and verify that it matches what we were given, if anything
    my $size = Mgd::get_file_size($path);
    return $self->err_line("size_mismatch")
        if $args->{size} && ($args->{size} != $size);

    # TODO: check for EIO?
    return $self->err_line("empty_file") unless $size;

    my $rv = $dbh->do("REPLACE INTO file ".
                      "SET ".
                      "  fid=?, dmid=?, dkey=?, length=?, ".
                      "  classid=?, devcount=0", undef,
                      $fid, $dmid, $key, $size, $trow->{classid});
    return $self->err_line("db_error") unless $rv;

    $dbh->do("DELETE FROM tempfile WHERE fid=?", undef, $fid);

    if (Mgd::update_fid_devcount($fid)) {
        return $self->ok_line();
    } else {
        # FIXME: handle this better
        return $self->err_line("db_error");
    }
}

sub cmd_delete {
    my Client $self = shift;
    my $args = shift;

    # validate parameters
    my $dmid = $self->check_domain($args) or return 0;
    my $key = $args->{key};
    return $self->err_line("no_key") unless length($key);

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");

    # is this fid still owned by this key?
    my $fid = $dbh->selectrow_array("SELECT fid FROM file WHERE dmid=? AND dkey=?",
                                    undef, $dmid, $key);
    return $self->err_line("unknown_key") unless $fid;

    $dbh->do("DELETE FROM file WHERE fid=?", undef, $fid);
    $dbh->do("REPLACE INTO file_to_delete SET fid=?", undef, $fid);

    return $self->ok_line();

}

sub cmd_get_hosts {
    my Client $self = shift;
    my $args = shift;

    my $dbh = Mgd::get_dbh()
        or return $self->err_line("nodb");

    Mgd::check_host_cache();

    my $ret = { hosts => 0 };
    while (my ($hostid, $row) = each %Mgd::cache_host) {
        next if defined $args->{hostid} && $hostid != $args->{hostid};

        $ret->{hosts}++;
        while (my ($key, $val) = each %$row) {
            $ret->{"host$ret->{hosts}_$key"} = $val;
        }
    }

    return $self->ok_line($ret);
}

sub cmd_get_devices {
    my Client $self = shift;
    my $args = shift;

    my $dbh = Mgd::get_dbh()
        or return $self->err_line("nodb");

    my $devs = Mgd::get_device_summary();

    my $ret = { devices => 0 };
    while (my ($devid, $row) = each %$devs) {
        next if defined $args->{devid} && $devid != $args->{devid};

        $ret->{devices}++;
        while (my ($key, $val) = each %$row) {
            $ret->{"dev$ret->{devices}_$key"} = $val;
        }
    }

    return $self->ok_line($ret);
}

sub cmd_get_paths {
    my Client $self = shift;
    my $args = shift;

    my $key = $args->{key};

    return $self->err_line("no_key") unless length($key);

    # validate domain
    my $dmid = $self->check_domain($args) or return 0;

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");
    
    my $filerow = Mgd::key_filerow($dbh, $dmid, $key);
    return $self->err_line("unknown_key") unless $filerow;

    my $fid = $filerow->{fid};
    my $dsum = Mgd::get_device_summary();

    # is this fid still owned by this key?
    my $devids = $dbh->selectcol_arrayref("SELECT devid FROM file_on WHERE fid=?",
                                          undef, $fid);

    my $ret = {
        paths => 0,
    };
    foreach my $devid (@{$devids || []}) {
        my $dev = $dsum->{$devid};
        next unless $dev && $dev->{status} eq "alive";
        my $path = Mgd::make_path($devid, $fid);
        next unless $ret->{paths} || $args->{noverify} ||
                        (Mgd::get_file_size($path) == $filerow->{length});
        my $n = ++$ret->{paths};
        $ret->{"path$n"} = $path;
        last if $n == 2;   # one verified, one likely seems enough for now.  time will tell.
    }

    return $self->ok_line($ret);
}

sub cmd_stats {
    my Client $self = shift;
    my $args = shift;

    # FIXME: DO!

}

sub ok_line {
    my Client $self = shift;
    my $args = shift;
    my $argline = join('&', map { eurl($_) . "=" . eurl($args->{$_}) } keys %$args);
    $self->write("OK $argline\r\n");
    return 1;
}

sub err_line {
    my Client $self = shift;
    my $err_code = shift;
    my $err_text = {
        'unknown_command' => "Unknown server command",
    }->{$err_code};

    $self->write("ERR $err_code " . eurl($err_text) . "\r\n");
    return 0;
}

sub eurl
{
    my $a = $_[0];
    $a =~ s/([^a-zA-Z0-9_\,\-.\/\\\: ])/uc sprintf("%%%02x",ord($1))/eg;
    $a =~ tr/ /+/;
    return $a;
}

sub durl
{
    my ($a) = @_;
    $a =~ tr/+/ /;
    $a =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
    return $a;
}

sub decode_url_args
{
    my $a = shift;
    my $buffer = ref $a ? $a : \$a;
    my $ret = {};

    my $pair;
    my @pairs = split(/&/, $$buffer);
    my ($name, $value);
    foreach $pair (@pairs)
    {
        ($name, $value) = split(/=/, $pair);
        $value =~ tr/+/ /;
        $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $name =~ tr/+/ /;
        $name =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $ret->{$name} .= $ret->{$name} ? "\0$value" : $value;
    }
    return $ret;
}


# Local Variables:
# mode: perl
# c-basic-indent: 4
# indent-tabs-mode: nil
# End:
