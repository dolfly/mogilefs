#!/usr/bin/perl
#
# MogileFS daemon
#
# Copyright 2004, Danga Interactive
# Copyright 2006, Six Apart Ltd.
#
# Authors:
#   Brad Fitzpatrick <brad@danga.com>
#   Brad Whitaker    <whitaker@danga.com>
#   Mark Smith       <junior@danga.com>
#
# License:
#   Artistic/GPLv2, at your choosing.
#

package Mgd;

# don't run as root
die "mogilefsd cannot be run as root\n"
    if $< == 0;

use strict;
use Getopt::Long;
use IO::Socket;
use Symbol;
use POSIX;
use DBI;
use DBD::mysql;
use File::Copy ();
use Carp;
use File::Basename ();
use File::Path ();
use Sys::Syslog;
use Socket qw(MSG_NOSIGNAL);
use Time::HiRes qw(gettimeofday tv_interval);
use Net::Netmask;
use LWP::UserAgent;
use List::Util;

use lib 'lib';
use MogileFS::Util;
use MogileFS::Connection::Client;
use MogileFS::Connection::Worker;
use MogileFS::Worker::Query;
use MogileFS::Worker::Delete;
use MogileFS::Worker::Replicate;
use MogileFS::Worker::Reaper;
use MogileFS::Worker::Monitor;
use MogileFS::ProcManager;

# this is incremented whenever the schema changes.  server will refuse
# to start-up with an old schema version
use constant SCHEMA_VERSION => 5;

#####################################################################
### C O N F I G
#####################################################################

use vars qw($dbh $DEFAULT_CONFIG $DEFAULT_MOG_ROOT $MOG_ROOT $MOGSTORED_STREAM_PORT $DEBUG $USE_HTTP $FLAG_NOSIGNAL);

$DEFAULT_CONFIG = "/etc/mogilefs/mogilefsd.conf";
$DEFAULT_MOG_ROOT = "/mnt/mogilefs";
$MOGSTORED_STREAM_PORT = 7501;
$DEBUG = 0;

# used in send() calls to request not to get SIGPIPEd
eval { $FLAG_NOSIGNAL = MSG_NOSIGNAL };

my (
    %cmdline,
    %cfgfile,
    $config,
    $skipconfig,
    $daemonize,
    $db_dsn,
    $db_user,
    $db_pass,
    $conf_port,
    $query_jobs,
    $delete_jobs,
    $replicate_jobs,
    $reaper_jobs,
    $monitor_jobs,
    $mog_root,
    $worker_port,
    $min_free_space,
    $max_disk_age,
    $node_timeout,          # time in seconds to wait for storage node responses
   );

our $default_mindevcount;

# Command-line options will override
Getopt::Long::Configure( "bundling" );
Getopt::Long::GetOptions(
    'c|config=s'    => \$config,
    's|skipconfig'  => \$skipconfig,
    'd|debug+'      => \$cmdline{debug},
    'D|daemon'      => \$cmdline{daemonize},
    'dsn=s'         => \$cmdline{db_dsn},
    'dbuser=s'      => \$cmdline{db_user},
    'dbpass=s'      => \$cmdline{db_pass},
    'r|mogroot=s'   => \$cmdline{mog_root},
    'p|confport=i'  => \$cmdline{conf_port},
    'w|workers=i'   => \$cmdline{query_jobs},
    'no_http'       => \$cmdline{no_http},
    'workerport=i'  => \$cmdline{worker_port},
    'maxdiskage=i'  => \$cmdline{max_disk_age},
    'minfreespace=i' => \$cmdline{min_free_space},
    'default_mindevcount=i' => \$cmdline{default_mindevcount},
    'node_timeout=i' => \$cmdline{node_timeout},
);

$config = $DEFAULT_CONFIG if !$config && -r $DEFAULT_CONFIG;

# Read the config file if one was specified
if ( $config && !$skipconfig ) {
    open my $cf, "<$config" or die "open: $config: $!";

    my $configLine = qr{
        ^\s*                    # Leading space
        (\w+)                   # Key
        \s+ =? \s*              # space + optional equal + optional space
        (.+?)                   # Value
        \s*$                    # Trailing space
    }x;

    my $linecount = 0;
    while (defined( my $line = <$cf> )) {
        $linecount++;
        next if $line =~ m{^\s*(#.*)?$};
        die "Malformed config file (line $linecount)" unless $line =~ $configLine;

        my ( $key, $value ) = ( $1, $2 );
        print STDERR "Setting '$key' to '$value'\n" if $cmdline{debug};
        $cfgfile{ $key } = $value;
    }

    close $cf;
}

### FUNCTION: choose_value( $name, $default[, $boolean] )
sub choose_value ($$;$) {
    my ( $name, $default, $boolean ) = @_;

    return $cmdline{$name} if defined $cmdline{$name};
    return $cfgfile{$name} if defined $cfgfile{$name};
    return $default;
}


# Fill in defaults for those values which were either loaded from config or
# specified on the command line. Command line takes precendence, then values in
# the config file, then the defaults.
$daemonize      = choose_value( 'daemonize', 0, 1 );
$db_dsn         = choose_value( 'db_dsn', "DBI:mysql:mogilefs" );
$db_user        = choose_value( 'db_user', "mogile" );
$db_pass        = choose_value( 'db_pass', "", 1 );
$conf_port      = choose_value( 'conf_port', 7001 );
$MOG_ROOT       = choose_value( 'mog_root', $DEFAULT_MOG_ROOT );
$query_jobs     = choose_value( 'listener_jobs', undef) || # undef if not present, then we
                  choose_value( 'query_jobs', 20 );       # fall back to query_jobs, new name
$delete_jobs    = choose_value( 'delete_jobs', 1 );
$replicate_jobs = choose_value( 'replicate_jobs', 1 );
$reaper_jobs    = choose_value( 'reaper_jobs', 1 );
$monitor_jobs   = choose_value( 'monitor_jobs', 1 );
$worker_port    = choose_value( 'worker_port', 7200 );
$min_free_space = choose_value( 'min_free_space', 100 );
$max_disk_age   = choose_value( 'max_disk_age', 5 );
$DEBUG          = choose_value( 'debug', 0, 1 );
$USE_HTTP       = ! choose_value( 'no_http', 0, 1);
$default_mindevcount = choose_value( 'default_mindevcount', 2 );
$node_timeout   = choose_value( 'node_timeout', 3 );

sub http_mode { return $USE_HTTP; }
sub mog_root  { return $MOG_ROOT; }
sub worker_port { return $worker_port; }

### initial setup
Mgd::validate_dbh();
my $dbh = Mgd::get_dbh();
unless ($dbh) {
    die <<NODB;
Error: unable to establish connection with your MogileFS database.

Please verify that you have correctly setup a configuration file or are
providing the correct information in order to reach the database and try
running the MogileFS server again.  If you haven't setup your database yet,
run 'mogdbsetup'.
NODB
}

my $sversion = $dbh->selectrow_array("SELECT value FROM server_settings WHERE field='schema_version'") || 0;
unless ($sversion == SCHEMA_VERSION) {
    my $exp = SCHEMA_VERSION;
    die "Server's database schema version of $sversion doesn't match expected value of $exp.  Halting.

Please run mogdbsetup to upgrade your schema.\n";
}

# we're done with this, so undef it before we start forking, as then
# maybe we'll end up with children having the same socket and everybody
# writing to it at the same time...
undef $dbh;

#####################################################################
### D A E M O N   F U N C T I O N S
#####################################################################

MogileFS::Util::daemonize() if $daemonize;

my %streamcache;    # host -> IO::Socket::INET to mogstored
our $starttime = time(); # time we got going

our %domaincache; # { domainname => { domainrow } }
our $domaincachetime = 0;
our $client_ip = undef; # client ip address
our $force_alt_zone = 0; # if on, force to use alternate zone (if it's defined)

MogileFS::ProcManager->set_min_workers('queryworker' => $query_jobs);
MogileFS::ProcManager->set_min_workers('delete'      => $delete_jobs);
MogileFS::ProcManager->set_min_workers('replicate'   => $replicate_jobs);
MogileFS::ProcManager->set_min_workers('reaper'      => $reaper_jobs);
MogileFS::ProcManager->set_min_workers('monitor'     => $monitor_jobs);

# open up our log
openlog('mogilefsd', 'pid', 'daemon');
Mgd::log('info', 'beginning run');

sub validate_dbh {
    return unless $dbh;
    my $id = $dbh->selectrow_array("SELECT CONNECTION_ID()");
    if (! $id) {
        # handle's dead.  don't use it.  (MySQL-ism above)
        undef $dbh;
    }
}

sub get_dbh {
    return $dbh ||= DBI->connect($db_dsn, $db_user, $db_pass, {
        PrintError => 0,
    });
}

# Install signal handlers.
$SIG{TERM}  = sub {
    my @children = MogileFS::ProcManager->child_pids;
    print STDERR scalar @children, " children to kill.\n" if $DEBUG;
    my $count = kill( 'TERM' => @children );
    print STDERR "Sent SIGTERM to $count children.\n" if $DEBUG;
    exit 0;
};
$SIG{INT}  = sub {
    my @children = MogileFS::ProcManager->child_pids;
    print STDERR scalar @children, " children to kill.\n" if $DEBUG;
    my $count = kill( 'INT' => @children );
    print STDERR "Sent SIGINT to $count children.\n" if $DEBUG;
    exit 0;
};
$SIG{PIPE} = 'IGNORE';  # catch them by hand

#############################################################################
## beginning of main execution path
#############################################################################

# setup server socket to listen for client connections
my $server = IO::Socket::INET->new(LocalPort => $conf_port,
                                   Type      => SOCK_STREAM,
                                   Proto     => 'tcp',
                                   Blocking  => 0,
                                   Reuse     => 1,
                                   Listen    => 10 )
    or die "Error creating socket: $@\n";

# accept handler for new clients
my $accept_handler = sub {
    my $csock = $server->accept();
    return unless $csock;

    printf( "Listen child making a Client for %d.\n", fileno($csock) )
        if $DEBUG >= 2;
    my $client = MogileFS::Connection::Client->new($csock);
    printf( "Client is %s\n", $client ) if $DEBUG >= 2;
};

# now setup socket for workers to connect to
my $wserver = IO::Socket::INET->new(LocalPort => $worker_port,
                                    LocalAddr => '127.0.0.1',
                                    Type      => SOCK_STREAM,
                                    Proto     => 'tcp',
                                    Blocking  => 0,
                                    Reuse     => 1,
                                    Listen    => 10 )
    or die "Error creating socket: $@\n";

# accept handler for new workers
my $waccept_handler = sub {
    my $csock = $wserver->accept();
    return unless $csock;

    printf( "Listen child making a Worker connection for %d.\n", fileno($csock) )
        if $DEBUG >= 2;
    my $client = MogileFS::Connection::Worker->new($csock);
    printf( "Child is %s\n", $client ) if $DEBUG >= 2;
    MogileFS::ProcManager->RegisterWorkerConn($client);
};

# so children can close these once they fork
sub close_listeners {
    close($server);
    close($wserver);
}

# setup Danga::Socket to start handling connections
Danga::Socket->DebugLevel( 3 );
Danga::Socket->OtherFds( fileno($server)  => $accept_handler,
                  fileno($wserver) => $waccept_handler, );

# setup the post event loop callback to spawn jobs, and the timeout
Danga::Socket->SetLoopTimeout( 250 ); # 250 milliseconds
Danga::Socket->SetPostLoopCallback(MogileFS::ProcManager->PostEventLoopChecker);

# and now, actually start listening for events
eval {
    print( "Starting event loop for frontend job on pid $$.\n" ) if $DEBUG;
    Danga::Socket->EventLoop();
};

if ( $@ ) { Mgd::log('err', "crash log: $@"); }
Mgd::log('info', 'ending run');
closelog();

# log stuff to syslog or the screen
sub log {
    # simple logging functionality
    if (! $daemonize) {
        # syslog acts like printf so we have to use printf and append a \n
        shift; # ignore the first parameter (info, warn, critical, etc)
        printf(shift(@_) . "\n", @_);
    } else {
        # just pass the parameters to syslog
        syslog(@_);
    }
}


# argument: a string to take as indicating the error that just happened.
sub error {
    # we're a parent, so just handle output of error
    MogileFS::ProcManager->NoteError(\$_[0]);
    Mgd::log('debug', $_[0]);
    return 0;
}

sub get_mindevcounts {
    # make sure we have good info
    Mgd::check_host_cache();
    my $host_ct = keys %Mgd::cache_host;

    # find the classes for each domainid (including domains without explict classes)
    my %min; # dmid -> classid -> mindevcount
    validate_dbh();
    my $dbh = get_dbh();
    my $sth = $dbh->prepare("SELECT d.dmid, c.classid, c.mindevcount ".
                            "FROM domain d LEFT JOIN class c ON d.dmid=c.dmid");
    $sth->execute;
    while (my ($dmid, $classid, $mct) = $sth->fetchrow_array) {
        $min{$dmid} ||= {};  # note the existence of this dmid

        # classid may be NULL (undef), in which case there are no classes defined
        # and we don't note the mindevcount (yet)
        $min{$dmid}{$classid} = int($host_ct < $mct ? $host_ct : $mct) if defined $classid;
    }


    # now iterate over %min again to set the implicit class
    foreach my $dmid (keys %min) {
        # each domain's classid=0, if not defined, has an implied mindevcount of $default_mindevcount
        # which most people will probably use.
        $min{$dmid}{0} = $host_ct < $default_mindevcount ? $host_ct : $default_mindevcount
            unless exists $min{$dmid}{0};
    }

    # return ref to hash
    return \%min;
}

#####################################################################
### S E R V E R   A P I   F U N C T I O N S
#####################################################################

# returns hashref of devid -> $device_row_href  (where devid is alive/down, but not dead)
# cached for 15 seconds.
use vars qw($cache_device_summary $cache_device_summary_time %cache_host $cache_host_time);

# general purpose device locator.  example:
#
# my $devid = Mgd::find_deviceid(
#     random => 1,              # get random device (else find first suitable)
#     min_free_space => 100,    # with at least 100MB free
#     weight_by_free => 1,      # find result weighted by free space
#     max_disk_age => 5,        # minutes of age the last usage report can be before we ignore the disk
#     not_on_hosts => [ 1, 2 ], # no devices on hosts 1 and 2
# );
#
# returns undef if no suitable device was found.  else, if you wanted an
# array will return an array of the suitable devices--if you want just a
# single item, you get just the first one found.
sub find_deviceid {
    my %opts = ( @_ );

    # copy down global minimum free space if not specified
    $opts{min_free_space} ||= $min_free_space;
    $opts{max_disk_age} ||= $max_disk_age;
    if ($opts{max_disk_age}) {
        $opts{max_disk_age} = time() - ($opts{max_disk_age} * 60);
    }

    # setup for iterating over devices
    my $devs = Mgd::get_device_summary();
    my @devids = keys %{$devs || {}};
    my $devcount = scalar(@devids);
    my $start = $opts{random} ? int(rand($devcount)) : 0;
    my %not_on_host = ( map { $_ => 1 } @{$opts{not_on_hosts} || []} );
    my $total_free = 0;

    # now find a device that matches what they want
    my @list;
    for (my $i = 0; $i < $devcount; $i++) {
        my $idx = ($i + $start) % $devcount;
        my $dev = $devs->{$devids[$idx]};

        # series of suitability checks
        next unless $dev->{status} eq 'alive';
        next if $not_on_host{$dev->{hostid}};
        next if $opts{max_disk_age} && $dev->{mb_asof} &&
                $dev->{mb_asof} < $opts{max_disk_age};
        next if $opts{min_free_space} && $dev->{mb_total} &&
                $dev->{mb_free} < $opts{min_free_space};

        # we get here, this is a suitable device
        push @list, $dev->{devid};
        $total_free += $dev->{mb_free};
    }

    # now we have a list ordered randomly, do free space weighting
    if ($opts{weight_by_free}) {
        my $rand = int(rand($total_free));
        my $cur = 0;

        foreach my $devid (@list) {
            $cur += $devs->{$devid}->{mb_free};
            return $devid if $cur >= $rand;
        }
    }

    # return whole list if wanting array, else just first item
    return wantarray ? @list : shift(@list);
}

# input:
#   given an array of arrayrefs of [ item, weight ], returns weighted randomized
#   list of items (without the weights, not arrayref; just list)
#
#   a weight of 0 means to exclude that item from the results list; i.e. it's not
#   ever used
#
# example:
#   my @items = weighted_list( [ 1, 10 ], [ 2, 20 ], [ 3, 0 ] );
#
#   returns (1, 2) or (2, 1) with the latter far more likely
sub weighted_list {
    my @list = grep { $_->[1] > 0 } @_;
    my @ret;

    my $sum = 0;
    $sum += $_->[1] foreach @list;

    my $getone = sub {
        return shift(@list)->[0]
            if scalar(@list) == 1;

        my $val = rand() * $sum;
        my $curval = 0;
        for (my $idx = 0; $idx < scalar(@list); $idx++) {
            my $item = $list[$idx];
            $curval += $item->[1];
            if ($curval >= $val) {
                my ($ret) = splice(@list, $idx, 1);
                $sum -= $item->[1];
                return $ret->[0];
            }
        }
    };

    push @ret, $getone->() while @list;
    return @ret;
}

sub get_device_summary {
    my $now = time;
    return $cache_device_summary if $cache_device_summary_time > $now - 15;

    my $dbh = get_dbh();

    # learn devices
    my %dev;  #
    my %hostdevs;  # hostid -> [ devid ]  (where devid is alive/down, but not dead)
    my $sth = $dbh->prepare("SELECT /*!40000 SQL_CACHE */ devid, hostid, mb_total, " .
                            "mb_used, mb_asof, status, weight FROM device");
    $sth->execute;
    $dev{$_->{devid}} = $_ while $_ = $sth->fetchrow_hashref;

    # now override device status with host status if the host status is less than the device status
    Mgd::check_host_cache();
    foreach my $devid (keys %dev) {
        # makes others have an easier time of finding devices by free space
        $dev{$devid}->{mb_free} = $dev{$devid}->{mb_total} - $dev{$devid}->{mb_used};

        my $host_status = $cache_host{$dev{$devid}->{hostid}}->{status};
        if ($dev{$devid}->{status} eq 'alive' && $host_status ne 'alive') {
            $dev{$devid}->{status} = $host_status;
        } elsif ($dev{$devid}->{status} eq 'down' && $host_status eq 'dead') {
            $dev{$devid}->{status} = $host_status;
        }
    }

    $cache_device_summary_time = $now;
    return $cache_device_summary = \%dev;
}

sub invalidate_device_cache {
    # so next time it's invalid and won't be used old
    $cache_device_summary_time = 0;
    $cache_device_summary = undef;
}

# FIXME: this should propogate to parent, and send messages down to
# query workers.  otherwise there's coherency issues between threads
# for a bit.
sub invalidate_host_cache {
    # so next time it's invalid and won't be used old
    $cache_host_time = 0;
    %cache_host = ();
}

sub check_host_cache {
    my $now = time;
    return if $cache_host_time > $now - 5;

    %cache_host = ();
    my $dbh = get_dbh();
    my $sth = $dbh->prepare("SELECT /*!40000 SQL_CACHE */ hostid, status, hostname, " .
                            "hostip, http_port, http_get_port, remoteroot, altip, altmask FROM host");
    $sth->execute;
    while (my $host = $sth->fetchrow_hashref) {
        $cache_host{$host->{hostid}} = $host;
        $cache_host{$host->{hostid}}->{mask} = Net::Netmask->new2($host->{altmask})
            if $host->{altip} && $host->{altmask};
    }
    $cache_host_time = $now;
}

sub key_filerow {
    my ($dbh, $dmid, $key) = @_;
    my $row = $dbh->selectrow_hashref("SELECT fid, dmid, dkey, length, classid, devcount ".
                                      "FROM file WHERE dmid=? AND dkey=?",
                                      undef, $dmid, $key);
    return $row;
}

# given a file descriptor number and a timeout, wait for that descriptor to
# become readable; returns 0 or 1 on if it did or not
sub wait_for_readability {
    my ($fileno, $timeout) = @_;
    return 0 unless $fileno && $timeout;

    my $rin;
    vec($rin, $fileno, 1) = 1;
    my $nfound = select($rin, undef, undef, $timeout);

    # nfound can be undef or 0, both failures, or 1, a success
    return $nfound ? 1 : 0;
}

# get size of file, return 0 on error
sub get_file_size {
    my $path = shift;

    # quick case -- just a file on disk
    unless ($path =~ m!^http://([^:/]+)(?::(\d+))?(/.+)$!) {
        return -s "$Mgd::MOG_ROOT/$path"
    }
    my ($host, $port, $uri) = ($1, $2, $3);

    # don't sigpipe us
    local $SIG{'PIPE'} = "IGNORE" unless $FLAG_NOSIGNAL;

    # setup for sending size request to cached host
    my $req = "size $uri\r\n";
    my $reqlen = length $req;
    my $rv = 0;
    my $sock = $streamcache{$host};

    # sub to parse the response from $sock.  returns undef on error,
    # or otherwise the size of the $path in bytes.
    my $parse_response = sub {
        # give the socket 3 seconds to become readable
        unless (Mgd::wait_for_readability(fileno($sock), $node_timeout)) {
            close($sock);
            return undef;
        }

        # now we know there's readable data
        my $line = <$sock>;
        return undef unless defined $line;
        return undef unless $line =~ /^(\S+)\s+(-?\d+)/; # expected format: "uri size"
        return error("get_file_size() requested size of $path, got back size of $1 ($2 bytes)")
            if $1 ne $uri;
        return 0 if $2 < 0;   # backchannel sends back -1 on errors, which we need to map to 0
        return $2+0;
    };

    # try using the cached socket
    if ($sock) {
        $rv = send($sock, $req, $FLAG_NOSIGNAL);
        if ($!) {
            undef $streamcache{$host};
        } elsif ($rv != $reqlen) {
            return error("send() didn't return expected length ($rv, not $reqlen) for $path");
        } else {
            # success
            my $size = $parse_response->();
            return $size if defined $size;
        }
    }

    # try creating a connection to the stream
    unless ($rv) {
        $sock = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $MOGSTORED_STREAM_PORT, Timeout => 5);
        $streamcache{$host} = $sock;
        if ($sock) {
            $rv = send($sock, $req, $FLAG_NOSIGNAL);
            if ($!) {
                return error("error talking to mogstored stream ($path): $!");
            } elsif ($rv != $reqlen) {
                return error("send() didn't return expected length ($rv, not $reqlen) for $path");
            } else {
                # success
                my $size = $parse_response->();
                return $size if defined $size;
            }
        }
    }

    # failure case: use a HEAD request to get the size of the file
    my $sock = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $port, Timeout => 3)
        or return error("get_file_size() unable to contact mogstored for size of $path");
    $sock->write("HEAD $uri HTTP/1.0\r\n\r\n");
    my $first = <$sock>;
    return error("get_file_size()'s HEAD request wasn't a 200 OK") unless $first =~ m!^HTTP/1\.\d 200!;
    while (defined (my $line = <$sock>)) {
        last if $line eq "\r\n";
        if ($line =~ /^Content-length: (\d+)/i) {
            # success
            return $1+0;
        }
    }

    # no content length found?
    return error("get_file_size() found no content-length header in response for $path");
}

sub class_id {
    my ($dmid, $class) = @_;
    return undef unless $dmid > 0 && length $class;

    my $dbh = Mgd::get_dbh;
    my $classid = $dbh->selectrow_array
        ("SELECT classid FROM class WHERE dmid=? AND classname=?", undef, $dmid, $class)
            or return undef;
    return undef unless $classid;
    return $classid;
}

sub hostid_classes {
    my $dmid = shift;
    return undef unless $dmid > 0;

    my $dbh = Mgd::get_dbh;
    my $classes = $dbh->selectall_arrayref
        ("SELECT classid, classname, mindevcount FROM class WHERE dmid=?", undef, $dmid)
            or return undef;
    return undef unless $classes;

    my $res = {};
    foreach my $row (@$classes) {
        $res->{$row->[0]} = {
            classid => $row->[0],
            classname => $row->[1],
            mindevcount => $row->[2],
        };
    }
    return $res;
}

sub host_id {
    my $host = shift;
    return undef unless $host;

    Mgd::check_host_cache();

    foreach my $hostid (keys %Mgd::cache_host) {
        return $hostid
            if $Mgd::cache_host{$hostid}->{hostname} eq $host;
    }

    return undef;
}

sub domain_id {
    # check the cache for this item
    my $now = time();
    if ($domaincachetime + 5 < $now) {
        %domaincache = ();

        # now get updated list
        my $dbh = Mgd::get_dbh;
        my $domains = $dbh->selectall_arrayref('SELECT dmid, namespace FROM domain');
        foreach my $row (@{$domains || []}) {
            # namespace -> dmid
            $domaincache{$row->[1]} = $row->[0];
        }

        $domaincachetime = $now;
    }

    # just use cached version
    return $domaincache{$_[0]};
}

sub class_name {
    my ($dmid, $classid) = @_;
    return undef unless $dmid > 0 && length $classid;
    # FIXME: cache this

    # lookup class
    my $dbh = Mgd::get_dbh;
    my $classname = $dbh->selectrow_array
        ("SELECT classname FROM class WHERE dmid=? AND classid=?", undef, $dmid, $classid)
            or return undef;
    return undef unless $classname;
    return $classname;
}

sub domain_name {
    my $dmid = shift;
    # FIXME: cache this

    # lookup domain
    my $dbh = Mgd::get_dbh;
    my $namespace = $dbh->selectrow_array
        ("SELECT namespace FROM domain WHERE dmid=?", undef, $dmid);
    return $namespace;

}

sub hostid_name {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{hostname} : undef;
}

sub set_force_altzone {
    my $val = shift;
    $force_alt_zone = $val;
}

sub set_client_ip {
    my $ip = shift;
    $client_ip = $ip;
}

sub hostid_ip {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return undef unless $h;

    # if we have a client ip and an object for alt matching...
    if ($h->{mask} && $h->{altip} &&
            ($force_alt_zone || ($client_ip && $h->{altip} && $h->{mask}->match($client_ip)))) {
        return $h->{altip};
    } else {
        return $h->{hostip};
    }
}

sub hostid_http_port {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{http_port} : undef;
}

sub hostid_http_get_port {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{http_get_port} : undef;
}

sub make_http_path {
    my ($devid, $fid) = @_;

    my $dsum = get_device_summary();
    my $dinfo = $dsum->{$devid};
    return undef unless $dinfo;
    my $hostname = hostid_name($dinfo->{hostid});

    my $nfid = sprintf '%010d', $fid;
    my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

    return "/dev$devid/$b/$mmm/$ttt/$nfid.fid";
}

sub make_full_url {
    # set use_get_port to be true to specify to use the get port
    my ($devid, $fid, $use_get_port) = @_;

    # get some information we'll need
    my $devs = Mgd::get_device_summary();
    my $dev = $devs->{$devid} or return undef;
    my $path = Mgd::make_http_path($devid, $fid) or return undef;
    my $host = Mgd::hostid_ip($dev->{hostid}) or return undef;
    my $port = $use_get_port ? Mgd::hostid_http_get_port($dev->{hostid}) : undef;
    $port ||= Mgd::hostid_http_port($dev->{hostid}) or return undef;
    return "http://$host:$port$path";
}

# if given an HTTP URL, break it down into [ host, port, URI ], else
# returns undef
sub is_url {
    my $path = shift;
    if ($path =~ m!^http://(.+?)(?::(\d+))?(/.+)$!) {
        return [ $1, $2 || 80, $3 ];
    }
    return undef;
}

sub make_path {
    # jump out if we should be using HTTP stuff
    return Mgd::make_full_url(@_) if $USE_HTTP;

    my ($devid, $fid) = @_;

    my $dsum = get_device_summary();
    my $dinfo = $dsum->{$devid};
    return undef unless $dinfo;
    my $hostname = hostid_name($dinfo->{hostid});

    my $nfid = sprintf '%010d', $fid;
    my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

    my $path = "$hostname/dev$devid/$b/$mmm/$ttt/$nfid.fid";
    make_dirs( "$MOG_ROOT/$path" ) or return undef;

    return $path;
}

sub make_get_path {
    # the get path only changes for HTTP mode
    return Mgd::make_path(@_) unless $USE_HTTP;
    return Mgd::make_full_url(@_, 1);
}

sub make_dirs
{
    my $filename = shift;
    my $dir = File::Basename::dirname($filename);
    eval { File::Path::mkpath($dir, 0, 0775); };
    return $@ ? 0 : 1;
}


sub update_fid_devcount {
    my ($fid, $no_lock) = @_;

    my $dbh = Mgd::get_dbh() or return 0;

    my $lockname = "mgfs:fid:$fid";
    unless ($no_lock) {
        my $lock = $dbh->selectrow_array("SELECT GET_LOCK(?, 10)", undef,
                                         $lockname);
        return 0 unless $lock;
    }
    my $ct = $dbh->selectrow_array("SELECT COUNT(*) FROM file_on WHERE fid=?",
                                   undef, $fid);

    $dbh->do("UPDATE file SET devcount=? WHERE fid=?", undef,
             $ct, $fid);

    unless ($no_lock) {
        $dbh->selectrow_array("SELECT RELEASE_LOCK(?)", undef, $lockname);
    }

    return 1;
}

1;

# Local Variables:
# mode: perl
# c-basic-indent: 4
# indent-tabs-mode: nil
# End:
