#!/usr/bin/perl
#
# MogileFS daemon - HEAVILY UNDER CONSTRUCTION
#
# Copyright 2004, Danga Interactive
#
# Authors:
#   Brad Fitzpatrick <brad@danga.com>
#
# License:
#   undecided.
#

package Mgd;

# don't run as root
die "mogilefsd cannot be run as root\n"
    if $< == 0;

use strict;
use Getopt::Long;
use IO::Socket;
use Symbol;
use POSIX;
use DBI;
use DBD::mysql;
use File::Copy ();
use Carp;
use File::Basename ();
use File::Path ();
use Socket qw(MSG_NOSIGNAL);


#####################################################################
### C O N F I G
#####################################################################

use vars qw($dbh $DEFAULT_CONFIG $DEFAULT_MOG_ROOT $MOG_ROOT $DEBUG $USE_HTTP $MOGSTORED_STREAM_PORT $FLAG_NOSIGNAL);

$DEFAULT_CONFIG = "/etc/mogilefs/mogilefsd.conf";
$DEFAULT_MOG_ROOT = "/mnt/mogilefs";
$MOGSTORED_STREAM_PORT = 7501; # FIXME make this configurable
$DEBUG = 0;

# used in send() calls to request not to get SIGPIPEd
eval { $FLAG_NOSIGNAL = MSG_NOSIGNAL };

my (
    %cmdline,
    %cfgfile,
    $config,
    $skipconfig,
    $daemonize,
    $db_dsn,
    $db_user,
    $db_pass,
    $conf_port,
    $query_jobs,
    $delete_jobs,
    $replicate_jobs,
    $mog_root,
    $default_mindevcount,
    $worker_port,
   );

# Command-line options will override
Getopt::Long::Configure( "bundling" );
Getopt::Long::GetOptions(
    'c|config=s'    => \$config,
    's|skipconfig'  => \$skipconfig,
    'd|debug+'      => \$cmdline{debug},
    'D|daemon'      => \$cmdline{daemonize},
    'dsn=s'         => \$cmdline{db_dsn},
    'dbuser=s'      => \$cmdline{db_user},
    'dbpass=s'      => \$cmdline{db_pass},
    'r|mogroot=s'   => \$cmdline{mog_root},
    'p|confport=i'  => \$cmdline{conf_port},
    'w|workers=i'   => \$cmdline{query_jobs},
    'no_http'       => \$cmdline{no_http},
    'workerport=i'  => \$cmdline{worker_port},
    'default_mindevcount=i' => \$cmdline{default_mindevcount},
);

$config = $DEFAULT_CONFIG if !$config && -r $DEFAULT_CONFIG;

# Read the config file if one was specified
if ( $config && !$skipconfig ) {
    open my $cf, "<$config" or die "open: $config: $!";

    my $configLine = qr{
        ^\s*                    # Leading space
        (\w+)                   # Key
        \s+ =? \s*              # space + optional equal + optional space
        (.+?)                   # Value
        \s*$                    # Trailing space
    }x;

    my $linecount = 0;
    while (defined( my $line = <$cf> )) {
        $linecount++;
        next if $line =~ m{^\s*(#.*)?$};
        die "Malformed config file (line $linecount)" unless $line =~ $configLine;

        my ( $key, $value ) = ( $1, $2 );
        print STDERR "Setting '$key' to '$value'\n" if $cmdline{debug};
        $cfgfile{ $key } = $value;
    }

    close $cf;
}

### FUNCTION: choose_value( $name, $default[, $boolean] )
sub choose_value ($$;$) {
    my ( $name, $default, $boolean ) = @_;

    if ( $boolean ) {
        return $cmdline{$name} if defined $cmdline{$name};
        return $cfgfile{$name} if defined $cfgfile{$name};
        return $default;
    }

    elsif ( !$boolean ) {
        return $cmdline{$name} || $cfgfile{ $name } || $default;
    }
}


# Fill in defaults for those values which were either loaded from config or
# specified on the command line. Command line takes precendence, then values in
# the config file, then the defaults.
$daemonize      = choose_value( 'daemonize', 0, 1 );
$db_dsn         = choose_value( 'db_dsn', "DBI:mysql:mogilefs" );
$db_user        = choose_value( 'db_user', "mogile" );
$db_pass        = choose_value( 'db_pass', "", 1 );
$conf_port      = choose_value( 'conf_port', 7001 );
$MOG_ROOT       = choose_value( 'mog_root', $DEFAULT_MOG_ROOT );
$query_jobs    = choose_value( 'listener_jobs', undef) || # undef if not present, then we
                  choose_value( 'query_jobs', 20 );       # fall back to query_jobs, new name
$delete_jobs    = choose_value( 'delete_jobs', 1 );
$replicate_jobs = choose_value( 'replicate_jobs', 1 );
$worker_port    = choose_value( 'worker_port', 7200 );
$DEBUG          = choose_value( 'debug', 0, 1 );
$USE_HTTP       = ! choose_value( 'no_http', 0, 1);
$default_mindevcount = choose_value( 'default_mindevcount', 2 );


#####################################################################
### D A E M O N   F U N C T I O N S
#####################################################################

daemonize() if $daemonize;

# keep track of what all child pids are doing, and what jobs are being
# satisifed.
my %child  = ();    # pids -> job
my %jobs   = ();    # jobname -> [ min, current ]
my %streamcache;    # host -> IO::Socket::INET to mogstored

# FIXME: make these configurable
$jobs{'frontend'} = [ 1, 0 ]; # only one frontend job
$jobs{'worker'} = [ $query_jobs, 0 ];
$jobs{'delete'} = [ $delete_jobs, 0 ];
$jobs{'replicate'} = [ $replicate_jobs, 0 ];

sub validate_dbh {
    return unless $dbh;
    my $id = $dbh->selectrow_array("SELECT CONNECTION_ID()");
    if (! $id) {
        # handle's dead.  don't use it.  (MySQL-ism above)
        undef $dbh;
    }
}

sub get_dbh {
    return $dbh ||= DBI->connect($db_dsn, $db_user, $db_pass);
}

# Install signal handlers.
$SIG{TERM}  = sub {
    print STDERR scalar keys %child, " children to kill.\n" if $DEBUG;
    my $count = kill( 'TERM' => keys %child );
    print STDERR "Sent SIGTERM to $count children.\n" if $DEBUG;
    exit 0;
};
$SIG{INT}  = sub {
    print STDERR scalar keys %child, " children to kill.\n" if $DEBUG;
    my $count = kill( 'INT' => keys %child );
    print STDERR "Sent SIGINT to $count children.\n" if $DEBUG;
    exit 0;
};


# Keep jobs alive
while (1) {
    my $pid = wait;

    # when a child dies, figure out what it was doing
    # and note that job has one less worker
    my $job;
    if ($pid > -1 && ($job = delete $child{$pid})) {
        print "Child $pid died: $?\n";

        if (my $jobstat = $jobs{$job}) {
            $jobstat->[1]--;
        }
    }

    # foreach job, fork enough children
    while (my ($job, $jobstat) = each %jobs) {
        my $need = $jobstat->[0] - $jobstat->[1];
        if ($need > 0) {
            print "Job $job has only $jobstat->[1], wants $jobstat->[0], making $need.\n"
                if $DEBUG;
            for (1..$need) {
                my $cpid = make_new_child($job);
                $child{$cpid} = $job;
                $jobstat->[1]++;
            }
        }
    }

}

sub daemonize {
    my($pid, $sess_id, $i);

    ## Fork and exit parent
    if ($pid = fork) { exit 0; }

    ## Detach ourselves from the terminal
    croak "Cannot detach from controlling terminal"
        unless $sess_id = POSIX::setsid();

    ## Prevent possibility of acquiring a controling terminal
    $SIG{'HUP'} = 'IGNORE';
    if ($pid = fork) { exit 0; }

    ## Change working directory
    chdir "/";

    ## Clear file creation mask
    umask 0;

    print STDERR "Daemon running as pid $$.\n" if $DEBUG;

    ## Close open file descriptors
    close(STDIN);
    close(STDOUT);
    close(STDERR);

    ## Reopen stderr, stdout, stdin to /dev/null
    if ( $DEBUG ) {
        open(STDIN,  "+>/tmp/mogilefsd.log");
    } else {
        open(STDIN,  "+>/dev/null");
    }
    open(STDOUT, "+>&STDIN");
    open(STDERR, "+>&STDIN");
}

sub make_new_child {
    my $job = shift;

    my $pid;
    my $sigset;

    # block signal for fork
    $sigset = POSIX::SigSet->new(SIGINT);
    sigprocmask(SIG_BLOCK, $sigset)
        or die "Can't block SIGINT for fork: $!\n";

    die "fork: $!" unless defined ($pid = fork);

    if ($pid) {
        sigprocmask(SIG_UNBLOCK, $sigset)
            or die "Can't unblock SIGINT for fork: $!\n";
        return $pid;
    }

    $SIG{INT} = 'DEFAULT';

    # unblock signals
    sigprocmask(SIG_UNBLOCK, $sigset)
        or die "Can't unblock SIGINT for fork: $!\n";

    no strict 'refs';
    my $job_handler = *{"job_$job"}{CODE};
    $job_handler->($$);
    exit;
}

sub job_delete {

  PASS:
    while (1) {
        sleep 9;
        validate_dbh();
        my $dbh = get_dbh();

        my $LIMIT = 500;
        while (1) {
            sleep 1;
            my $delmap = $dbh->selectall_arrayref("SELECT fd.fid, fo.devid ".
                                                  "FROM file_to_delete fd ".
                                                  "LEFT JOIN file_on fo ON fd.fid=fo.fid ".
                                                  "LIMIT $LIMIT");
            my $count = $delmap ? scalar @$delmap : 0;
            next PASS unless $count;

            my %done;  # fid -> 1 (when fid is deleted from all devices)
            my %dev_down;  # devid -> 1 (when device times out due to EIO)

            foreach my $dm (@$delmap) {
                my ($fid, $devid) = @$dm;

                # if no device is returned from the query above, that
                # means there are no file_on rows for it, and we can consider
                # it now deleted.
                unless ($devid) {
                    $done{$fid} = 1;
                    next;
                }

                # don't try to delete from this device if we earlier
                # found it to be timing out with EIO
                next if $dev_down{$devid};

                my $path = make_path($devid, $fid);
                my $rv = 0;
                if (my $urlref = Mgd::is_url($path)) {
                    # hit up the server and delete it
                    my $sock = IO::Socket::INET->new(PeerAddr => $urlref->[0],
                                                     PeerPort => $urlref->[1],
                                                     Timeout => 2);
                    unless ($sock) {
                        # timeout or something, mark this device as down for now and move on
                        $dev_down{$devid} = 1;
                        next;
                    }

                    # send delete request
                    print "Sending delete for $path\n" if $Mgd::DEBUG >= 2;
                    print $sock "DELETE $urlref->[2] HTTP/1.0\r\n\r\n";
                    my $response = <$sock>;
                    if ($response =~ m!^HTTP/\d+\.\d+\s+(\d+)!) {
                        if (($1 >= 200 && $1 <= 299) || $1 == 404) {
                            # effectively means all went well
                            $rv = 1;
                        } else {
                            # remote file system error?  mark node as down
                            warn "Error: unlink failure: $path: $1\n";
                            $dev_down{$devid} = 1;
                            next;
                        }
                    } else {
                        warn "Error: unknown response line: $response\n";
                    }
                } else {
                    # do normal unlink
                    $rv = unlink "$Mgd::MOG_ROOT/$path";

                    # device is timing out.  take note of it and
                    # continue dealing with other deletes
                    if (! $rv) {
                        if ($! == EIO) {
                            $dev_down{$devid} = 1;
                            next;
                        } elsif ($! == ENOENT) {
                            $rv = 1;  # count non-existent file as deleted
                        }
                    }
                }

                # if we deleted it, or it didn't exist, consider it
                # deleted.
                $dbh->do("DELETE FROM file_on WHERE fid=? AND devid=?",
                         undef, $fid, $devid) if $rv;
            }

            if (%done) {
                my $in = join(',', keys %done);
                $dbh->do("DELETE FROM file_to_delete WHERE fid IN ($in)");
            }

            next PASS if $count < $LIMIT;
        }

    }
}

# copies a file from one Perlbal to another utilizing HTTP
sub http_copy {
    my ($sdevid, $ddevid, $fid) = @_;

    # get some information we'll need
    my $devs = Mgd::get_device_summary();
    my ($sdev, $ddev) = ($devs->{$sdevid}, $devs->{$ddevid});
    unless (ref $sdev && ref $ddev) {
        warn "Error: unable to get device information: source=$sdevid, destination=$ddevid, fid=$fid\n";
        return 0;
    }
    my ($spath, $dpath) = (Mgd::make_http_path($sdevid, $fid),
                           Mgd::make_http_path($ddevid, $fid));
    my ($shost, $sport) = (Mgd::hostid_ip($sdev->{hostid}), Mgd::hostid_http_port($sdev->{hostid}));
    my ($dhost, $dport) = (Mgd::hostid_ip($ddev->{hostid}), Mgd::hostid_http_port($ddev->{hostid}));
    unless (defined $spath && defined $dpath && defined $shost && defined $dhost && $sport && $dport) {
        # show detailed information to find out what's not configured right
        warn "Error: unable to replicate file fid=$fid from device id $sdevid to device id $ddevid\n";
        warn "       http://$shost:$sport$spath -> http://$dhost:$dport$dpath\n";
        return 0;
    }
    print "http://$shost:$sport$spath -> http://$dhost:$dport$dpath\n" if $Mgd::DEBUG >= 2;

    # setup our pipe error handler, in case we get closed on
    my $pipe_closed = 0;
    local $SIG{PIPE} = sub { $pipe_closed = 1; };

    # okay, now get the file
    my $sock = IO::Socket::INET->new(PeerAddr => $shost, PeerPort => $sport, Timeout => 2)
        or return 0;
    print $sock "GET $spath HTTP/1.0\r\n\r\n";
    return 0 if $pipe_closed;

    # we just want a content length
    my $clen;
    while (defined (my $line = <$sock>)) {
        $line =~ s/[\s\r\n]+$//;
        last unless length $line;
        if ($line =~ m!^HTTP/\d+\.\d+\s+(\d+)!) {
            # make sure we get a good response
            unless ($1 >= 200 && $1 <= 299) {
                warn "Error: Resource http://$shost:$sport$spath failed: HTTP $1\n";
                return 0;
            }
        }
        next unless $line =~ /^Content-length:\s*(\d+)\s*$/i;
        $clen = $1;
    }
    return 0 unless $clen;

    # open target for put
    my $dsock = IO::Socket::INET->new(PeerAddr => $dhost, PeerPort => $dport, Timeout => 2) or return 0;
    $dsock->write("PUT $dpath HTTP/1.0\r\nContent-length: $clen\r\n\r\n") or return 0;
    return 0 if $pipe_closed;

    # now read data and print while we're reading
    my ($data, $read) = ('', 0);
    while (!$pipe_closed && (my $bytes = read($sock, $data, $clen - $read))) {
        $read += $bytes;
        last unless $dsock->write($data);
    }

    # now read in the response line (should be first line)
    my $line = <$dsock>;
    if ($line =~ m!^HTTP/\d+\.\d+\s+(\d+)!) {
        return 1 if $1 >= 200 && $1 <= 299;
        warn "Error: got a 404 in put: device not on host?: http://$dhost:$dport$dpath" if $1 == 404;
    } else {
        warn "Error: HTTP response line not recognized: $line";
    }
    return 0;
}

# replicates $fid if its devcount is less than $min.
sub replicate {
    my ($dbh, $fid, $min) = @_;

    print "Replicating: $fid (need $min)\n" if $Mgd::DEBUG >= 2;

    my $lockname = "mgfs:fid:$fid:replicate";
    my $lock = $dbh->selectrow_array("SELECT GET_LOCK(?, 1)", undef,
                                     $lockname);
    return 0 unless $lock;

    # hashref of devid -> $device_row_href  (where devid is alive)
    my $devs = Mgd::get_device_summary();
    return 0 unless $devs && %$devs;

    # learn what devices this file is already on
    my $on_count = 0;
    my %on_host;     # hostid -> 1
    my @dead_devid;   # list of dead devids
    my @exist_devid;  # list of existing devids

    my $sth = $dbh->prepare("SELECT devid FROM file_on WHERE fid=?");
    $sth->execute($fid);
    die $dbh->errstr if $dbh->err;
    while (my ($devid) = $sth->fetchrow_array) {
        my $d = $devs->{$devid};
        unless ($d) {
            push @dead_devid, $devid;
            next;
        }
        $on_host{$d->{hostid}} = 1;
        $on_count++;
        push @exist_devid, $devid;
    }

    my $retunlock = sub {
        my $rv = shift;
        $dbh->selectrow_array("SELECT RELEASE_LOCK(?)", undef, $lockname);
        return $rv;
    };

    return $retunlock->(1) if $on_count >= $min;
    return $retunlock->(0) if $on_count == 0;
    return $retunlock->(0) if @exist_devid == 0;

    my $sdevid;

    while ($on_count < $min) {
        my $need = $min - $on_count;

        my @good_devids = randlist(grep {
            $devs->{$_}{status} eq 'alive' && ! $on_host{$devs->{$_}{hostid}}
        } keys %$devs);

        # wasn't able to replicate enough?
        last unless @good_devids;

        my $ddevid = shift @good_devids;
        $sdevid ||= @exist_devid[int(rand(scalar @exist_devid))];

        my $rv = undef;
        if ($USE_HTTP) {
            $rv = http_copy($sdevid, $ddevid, $fid);
        } else {
            my $dst_path = $MOG_ROOT . "/" . make_path($ddevid, $fid);
            my $src_path = $MOG_ROOT . "/" . make_path($sdevid, $fid);
            $rv = File::Copy::copy($src_path, $dst_path);
        }

        return $retunlock->(0) unless $rv;
        add_file_on($fid, $ddevid, 1);
        $on_count++;
    }

    return $retunlock->(1);
}

sub job_replicate {
    while (1) {
        sleep 2;
        validate_dbh();
        my $dbh = get_dbh() or return 0;

        Mgd::check_host_cache();
        my $host_ct = keys %Mgd::cache_host;

        # find the classes for each domainid (including domains without explict classes)
        my %min; # dmid -> classid -> mindevcount
        my $sth = $dbh->prepare("SELECT d.dmid, c.classid, c.mindevcount ".
                                "FROM domain d LEFT JOIN class c ON d.dmid=c.dmid");
        $sth->execute;
        while (my ($dmid, $classid, $mct) = $sth->fetchrow_array) {
            $min{$dmid} ||= {};  # note the existence of this dmid

            # classid may be NULL (undef), in which case there are no classes defined
            # and we don't note the mindevcount (yet)
            $min{$dmid}{$classid} = int($host_ct < $mct ? $host_ct : $mct) if defined $classid;
        }

        # iterate through each domain, replicating its contents
        foreach my $dmid (keys %min) {
            # each domain's classid=0, if not defined, has an implied mindevcount of $default_mindevcount
            # which most people will probably use.
            $min{$dmid}{0} = $host_ct < $default_mindevcount ? $host_ct : $default_mindevcount
                unless exists $min{$dmid}{0};

            # iterate through each class, including the implicit class 0
            while (my ($classid, $min) = each %{$min{$dmid}}) {

                print "Checking replication for dmid=$dmid, classid=$classid, min=$min\n" if $Mgd::DEBUG >= 1;

                my $LIMIT = 1000;
                while (1) {
                    my $fids = $dbh->selectcol_arrayref("SELECT fid FROM file WHERE dmid=? AND classid=? ".
                                                        "AND devcount>0 AND devcount<? AND length IS NOT NULL ".
                                                        "LIMIT $LIMIT", undef, $dmid, $classid, $min);
                    die $dbh->errstr if $dbh->err;
                    my $count = $fids ? scalar @$fids : 0;
                    print "  found $count for dmid=$dmid/classid=$classid/min=$min\n" if $Mgd::DEBUG >= 1;
                    last unless $count;
                    my $fixed = 0;

                    # randomize the list so multiple daemons/threads working on
                    # replicate at the same time don't all fight over the
                    # same fids to move
                    my @rand_finds = randlist(@$fids);

                    print "Need to replicate: $dmid/$classid: @$fids\n" if $Mgd::DEBUG >= 2;
                    foreach my $fid (@rand_finds) {
                        $fixed++ if replicate($dbh, $fid, $min);
                    }

                    last unless $count == $LIMIT || $fixed != $count;
                }

            }
        }
    }
}

sub job_frontend {
    # setup server socket to listen for client connections
    my $server = IO::Socket::INET->new(LocalPort => $conf_port,
                                       Type      => SOCK_STREAM,
                                       Proto     => 'tcp',
                                       Blocking  => 0,
                                       Reuse     => 1,
                                       Listen    => 10 )
        or die "Error creating socket: $@\n";

    # accept handler for new clients
    my $accept_handler = sub {
        my $csock = $server->accept();
        printf( "Listen child making a Client for %d.\n", fileno($csock) )
            if $DEBUG >= 2;
        my $client = Client->new($csock);
        printf( "Client is %s\n", $client ) if $DEBUG >= 2;
        $client->watch_read(1);
    };

    # now setup socket for workers to connect to
    my $wserver = IO::Socket::INET->new(LocalPort => $worker_port,
                                        Type      => SOCK_STREAM,
                                        Proto     => 'tcp',
                                        Blocking  => 0,
                                        Reuse     => 1,
                                        Listen    => 10 )
        or die "Error creating socket: $@\n";

    # accept handler for new workers
    my $waccept_handler = sub {
        my $csock = $wserver->accept();
        printf( "Listen child making a Client for %d.\n", fileno($csock) )
            if $DEBUG >= 2;
        my $client = Client->new($csock);
        printf( "Worker is %s\n", $client ) if $DEBUG >= 2;
        Frontend->RegisterWorker($client);
    };
    
    # setup Danga::Socket to start handling connections
    Client->DebugLevel( 3 );
    Client->OtherFds( fileno($server)  => $accept_handler,
                      fileno($wserver) => $waccept_handler, );

    # and now, actually start listening for events
    eval {
        print( "Starting event loop for frontend job on pid $$.\n" ) if $DEBUG;
        Client->EventLoop();
    };

    if ( $@ ) { print STDERR "ERR: client_listen: $@\n" }
}

sub job_worker {
    # connect to master
    my $msock = IO::Socket::INET->new(PeerAddr => "127.0.0.1",
                                      PeerPort => $worker_port,
                                      Type     => SOCK_STREAM,
                                      Proto    => 'tcp',)
        or die "Error creating socket to master: $@\n";

    # process lines of input, blocking.
    my $worker = Worker->new($msock);
    while (defined (my $line = <$msock>)) {
        $line =~ s/[\r\n]+$//;
        validate_dbh();
        $worker->process_line(\$line);
    }
}


#####################################################################
### S E R V E R   A P I   F U N C T I O N S
#####################################################################

# returns hashref of devid -> $device_row_href  (where devid is alive/down, but not dead)
# cached for 15 seconds.
use vars qw($cache_device_summary $cache_device_summary_time %cache_host $cache_host_time);

sub get_device_summary {
    my $now = time;
    return $cache_device_summary if $cache_device_summary_time > $now - 15;

    my $dbh = get_dbh();

    # learn devices
    my %dev;  #
    my %hostdevs;  # hostid -> [ devid ]  (where devid is alive/down, but not dead)
    my $sth = $dbh->prepare("SELECT /*!40000 SQL_CACHE */ devid, hostid, mb_total, mb_used, status ".
                            "FROM device ".
                            "WHERE status IN ('alive', 'down')");
    $sth->execute;
    $dev{$_->{devid}} = $_ while $_ = $sth->fetchrow_hashref;

    $cache_device_summary_time = $now;
    return $cache_device_summary = \%dev;
}

sub check_host_cache {
    my $now = time;
    return if $cache_host_time > $now - 2;

    %cache_host = ();
    my $dbh = get_dbh();
    my $sth = $dbh->prepare("SELECT /*!40000 SQL_CACHE */ hostid, status, hostname, hostip, http_port, remoteroot FROM host");
    $sth->execute;
    $cache_host{$_->{hostid}} = $_ while $_ = $sth->fetchrow_hashref;
    $cache_host_time = $now;
}

sub key_filerow {
    my ($dbh, $dmid, $key) = @_;
    my $row = $dbh->selectrow_hashref("SELECT fid, dmid, dkey, length, classid, devcount ".
                                      "FROM file WHERE dmid=? AND dkey=?",
                                      undef, $dmid, $key);
    return $row;
}

# get size of file, return 0 on error
sub get_file_size {
    my $path = shift;

    # quick case -- just a file on disk
    unless ($path =~ m!^http://([^:/]+)(?::(\d+))?(/.+)$!) {
        return -s "$Mgd::MOG_ROOT/$path"
    }
    my ($host, $port, $uri) = ($1, $2, $3);

    # don't sigpipe us
    local $SIG{'PIPE'} = "IGNORE" unless $FLAG_NOSIGNAL;

    # setup for sending size request to cached host
    my $req = "size $uri\r\n";
    my $reqlen = length $req;
    my $rv = 0;
    my $sock = $streamcache{$host};

    # handle errors
    my $error = sub {
        print STDERR $_[0];
        return 0;
    };

    # sub to parse the response from $sock.  common code, so we have it here.
    my $parse_response = sub {
        my $line = <$sock>;
        return 0 unless defined $line;
        return 0 unless $line =~ /^(\S+)\s+(-?\d+)/; # expected format: "uri size"
        return $error->("get_file_size() requested size of $path, got back size of $1 ($2 bytes)")
            if $1 ne $uri;
        return $2+0;
    };

    # try using the cached socket
    if ($sock) {
        $rv = send($sock, $req, $FLAG_NOSIGNAL);
        if ($!) {
            undef $streamcache{$host};
        } elsif ($rv != $reqlen) {
            return $error->("send() didn't return expected length ($rv, not $reqlen) for $path");
        } else {
            # success
            return $parse_response->();
        }
    }

    # try creating a connection to the stream
    unless ($rv) {
        $sock = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $MOGSTORED_STREAM_PORT, Timeout => 5);
        $streamcache{$host} = $sock;
        if ($sock) {
            $rv = send($sock, $req, $FLAG_NOSIGNAL);
            if ($!) {
                return $error->("error talking to mogstored stream ($path): $!");
            } elsif ($rv != $reqlen) {
                return $error->("send() didn't return expected length ($rv, not $reqlen) for $path");
            } else {
                # success
                return $parse_response->();
            }
        }
    }

    # failure case: use a HEAD request to get the size of the file
    my $sock = IO::Socket::INET->new(PeerAddr => $host, PeerPort => $port, Timeout => 3)
        or return $error->("get_file_size() unable to contact mogstored for size of $path");
    $sock->write("HEAD $uri HTTP/1.0\r\n\r\n");
    while (defined (my $line = <$sock>)) {
        if ($line =~ /^Content-length: (\d+)/i) {
            # success
            return $1+0;
        }
    }

    # no content length found?
    return $error->("get_file_size() found no content-length header in response for $path");
}

sub class_id {
    my ($dmid, $class) = @_;
    return undef unless $dmid > 0 && length $class;

    my $dbh = Mgd::get_dbh;
    my $classid = $dbh->selectrow_array
        ("SELECT classid FROM class WHERE dmid=? AND classname=?", undef, $dmid, $class)
            or return undef;
    return undef unless $classid;
    return $classid;
}

sub domain_id {
    my $domain = shift;
    # FIXME: cache this

    my $dbh = Mgd::get_dbh;
    # lookup domain
    my $dmid = $dbh->selectrow_array("SELECT dmid FROM domain WHERE namespace=?",
                                     undef, $domain);
    return $dmid;
}

sub hostid_name {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{hostname} : undef;
}

sub hostid_ip {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{hostip} : undef;
}

sub hostid_http_port {
    my $hostid = shift;
    check_host_cache();
    my $h = $cache_host{$hostid};
    return $h ? $h->{http_port} : undef;
}

sub make_http_path {
    my ($devid, $fid) = @_;

    my $dsum = get_device_summary();
    my $dinfo = $dsum->{$devid};
    return undef unless $dinfo;
    my $hostname = hostid_name($dinfo->{hostid});

    my $nfid = sprintf '%010d', $fid;
    my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

    return "/dev$devid/$b/$mmm/$ttt/$nfid.fid";
}

sub make_full_url {
    my ($devid, $fid) = @_;

    # get some information we'll need
    my $devs = Mgd::get_device_summary();
    my $dev = $devs->{$devid} or return undef;
    my $path = Mgd::make_http_path($devid, $fid) or return undef;
    my $host = Mgd::hostid_ip($dev->{hostid}) or return undef;
    my $port = Mgd::hostid_http_port($dev->{hostid}) or return undef;
    return "http://$host:$port$path";
}

# if given an HTTP URL, break it down into [ host, port, URI ], else
# returns undef
sub is_url {
    my $path = shift;
    if ($path =~ m!^http://(.+?)(?::(\d+))?(/.+)$!) {
        return [ $1, $2 || 80, $3 ];
    }
    return undef;
}

sub make_path {
    # jump out if we should be using HTTP stuff
    return Mgd::make_full_url(@_) if $USE_HTTP;
    
    my ($devid, $fid) = @_;

    my $dsum = get_device_summary();
    my $dinfo = $dsum->{$devid};
    return undef unless $dinfo;
    my $hostname = hostid_name($dinfo->{hostid});

    my $nfid = sprintf '%010d', $fid;
    my ( $b, $mmm, $ttt, $hto ) = ( $nfid =~ m{(\d)(\d{3})(\d{3})(\d{3})} );

    my $path = "$hostname/dev$devid/$b/$mmm/$ttt/$nfid.fid";
    make_dirs( "$MOG_ROOT/$path" ) or return undef;

    return $path;
}

sub make_dirs
{
    my $filename = shift;
    my $dir = File::Basename::dirname($filename);
    eval { File::Path::mkpath($dir, 0, 0775); };
    return $@ ? 0 : 1;
}

sub add_file_on {
    my ($fid, $devid, $no_lock) = @_;

    my $dbh = get_dbh() or return 0;

    my $rv = $dbh->do("INSERT IGNORE INTO file_on SET fid=?, devid=?",
                      undef, $fid, $devid);
    if ($rv > 0) {
        return update_fid_devcount($fid, $no_lock);
    } else {
        # was already on that device
        return 1;
    }
}

sub update_fid_devcount {
    my ($fid, $no_lock) = @_;

    my $dbh = get_dbh() or return 0;

    my $lockname = "mgfs:fid:$fid";
    unless ($no_lock) {
        my $lock = $dbh->selectrow_array("SELECT GET_LOCK(?, 10)", undef,
                                         $lockname);
        return 0 unless $lock;
    }
    my $ct = $dbh->selectrow_array("SELECT COUNT(*) FROM file_on WHERE fid=?",
                                   undef, $fid);

    $dbh->do("UPDATE file SET devcount=? WHERE fid=?", undef,
             $ct, $fid);

    unless ($no_lock) {
        $dbh->selectrow_array("SELECT RELEASE_LOCK(?)", undef, $lockname);
    }

    return 1;
}

sub randlist
{
    my @rlist = @_;
    my $size = scalar(@rlist);

    my $i;
    for ($i=0; $i<$size; $i++)
    {
        unshift @rlist, splice(@rlist, $i+int(rand()*($size-$i)), 1);
    }
    return @rlist;
}

#####################################################################
### F R O N T E N D  C L A S S
### This class handles keeping lists of workers and clients and
### assigning them to eachother when things happen.  This is a purely
### event driven class.
#####################################################################
package Client; # define it so that "my Client" works
package Frontend;

# Mappings: fd => [ clientref, jobstring ]
# queues are just lists of Client class objects
our (@WorkerQueue, @ClientQueue, %Mappings);

# take a new worker and note that it's a worker and ready to be used
# for commands.  this is called when workers connect to the frontend.
sub RegisterWorker {
    # basically take the worker, mark it as a worker, enqueue it,
    # and then try to process the outstanding queues
    my Client $worker = $_[1];
    $worker->isWorker(1);
    Frontend->EnqueueWorker($worker);
}

# puts a worker back in the queue, deleting any outstanding jobs in
# the mapping list for this fd.
sub EnqueueWorker {
    # first arg is class, second is worker
    my Client $worker = $_[1];
    delete $Mappings{$worker->{fd}};
    push @WorkerQueue, $worker;
    Frontend->ProcessQueues;
}

# called when we get a response from a worker.  this reenqueues the
# worker so it can handle another response as well as passes the answer
# back on to the client.
sub HandleWorkerResponse {
    # got a response from a worker
    my Client $worker = $_[1];
    return unless $worker;

    # get client; fail if we don't have one or it's closed
    my Client $client = $Mappings{$worker->{fd}}->[0];
    return Frontend->EnqueueWorker($worker) if !$client || $client->{closed};

    # send text to client, put worker back in queue
    $client->write($_[2] . "\r\n");
    Frontend->EnqueueWorker($worker);
}

# called from various spots to empty the queues of available pairs.
sub ProcessQueues {
    # try to match up a client with a worker
    while (@WorkerQueue && @ClientQueue) {
        # get client that isn't closed
        my $clref;
        while (@ClientQueue) {
            $clref = shift @ClientQueue;
            if (!defined $clref || $clref->[0]->{closed}) {
                $clref = undef;
                next;
            }

            # if we get here the client is valid
            last;
        }
        
        # get worker and make sure it's not closed already
        my Client $worker = shift @WorkerQueue;
        if (!defined $worker || $worker->{closed}) {
            unshift @ClientQueue, $clref;
            next;
        }

        # put in mapping and send data to worker
        $Mappings{$worker->{fd}} = $clref;
        $worker->write($clref->[1] . "\r\n");
        $worker->watch_read(1);
    }
}

# called when a client sends us text.  we just create a job for
# it and then call ProcessQueues.
sub HandleClientRequest {
    # just push the input onto the client queue
    push @ClientQueue, [ $_[1], $_[2] ];
    Frontend->ProcessQueues;
}

# called when we notice that a client has died.  we may need to
# replay their request at another backend.
sub NoteDeadClient {
    my Client $client = $_[1];
    return unless $client->isWorker;

    # if there's a mapping for this worker's fd, they had a job that didn't get done
    if ($Mappings{$client->{fd}}) {
        # unshift, since this one already went through the queue once
        unshift @ClientQueue, $Mappings{$client->{fd}};
        delete $Mappings{$client->{fd}};
        Frontend->ProcessQueues;
    }
}

#####################################################################
### C L I E N T   C L A S S
### Workers and users are both clients.  We keep track of which we
### are with a flag, though, and we use that to determine how we
### should handle input.  This class is just a connection to the
### client or worker.
#####################################################################
package Client;

use Danga::Socket ();
use base qw{Danga::Socket};

use fields qw{read_buf is_worker};

sub new {
    my Client $self = shift;
    $self = fields::new($self) unless ref $self;
    $self->SUPER::new( @_ );

    # mark as not a worker by default
    $self->{is_worker} = 0;

    $self->debugmsg( 3, "New client for %d running.", $self->{fd} );
    return $self;
}

# Client
sub event_read {
    my Client $self = shift;
    $self->debugmsg( 3, "Read event on %d.", $self->{fd} );

    my $bref = $self->read(1024);
    return $self->close() unless defined $bref;
    $self->{read_buf} .= $$bref;

    if ($self->{read_buf} =~ s/^(.+?)\r?\n//) {
        if ($self->isWorker) {
            Frontend->HandleWorkerResponse($self, $1);
        } else {
            Frontend->HandleClientRequest($self, $1);
        }
    }
}

sub isWorker {
    my Client $self = shift;
    return $self->{is_worker} unless @_;
    return $self->{is_worker} = shift;
}

# Client
sub event_err {  my $self = shift; $self->close; }
sub event_hup {  my $self = shift; $self->close; }

sub close {
    # mark us as being dead
    my Client $self = shift;
    Frontend->NoteDeadClient($self);
    $self->SUPER::close(@_);
}


#####################################################################
### W O R K E R   C L A S S
### Class that handles all of the actions that a worker can take.
#####################################################################
package Worker;

use fields qw{sock};

sub new {
    my Worker $self = shift;

    $self = fields::new($self) unless ref $self;
    $self->{sock} = shift;

    return $self;
}

sub process_line {
    my Worker $self = shift;
    my $lineref = shift;

    if ($$lineref =~ /^(\w+)\s*(.*)/) {
        my ($cmd, $args) = ($1, $2);
        $cmd = lc($cmd);

        no strict 'refs';
        my $cmd_handler = *{"cmd_$cmd"}{CODE};
        if ($cmd_handler) {
            my $args = decode_url_args(\$args);
            $cmd_handler->($self, $args);
            next;
        }
    }

    return $self->err_line('unknown_command');
}

# returns 0 on error, or dmid of domain
sub check_domain {
    my Worker $self = shift;
    my $args = shift;

    return $self->err_line("no_domain") unless length($args->{domain});

    # validate domain
    my $dmid = Mgd::domain_id($args->{domain}) or
        return $self->err_line("unreg_domain");

    return $dmid;
}

sub cmd_sleep {
    my Worker $self = shift;
    my $args = shift;
    sleep($args->{duration} || 10);
    return $self->ok_line;
}

sub cmd_create_open {
    my Worker $self = shift;
    my $args = shift;

    # validate parameters
    my $dmid = $self->check_domain($args) or return 0;
    my $key = $args->{key} || "";

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");

    # figure out what classid this file is for
    my $class = $args->{class};
    my $classid = 0;
    if (length($class)) {
        # TODO: cache this
        $classid = $dbh->selectrow_array("SELECT classid FROM class ".
                                         "WHERE dmid=? AND classname=?",
                                         undef, $dmid, $class)
            or return $self->err_line("unreg_class");
    }

    # setup the new mapping
    $dbh->do("INSERT INTO tempfile SET ".
             " fid=NULL, dmid=?, dkey=?, classid=?",
             undef, $dmid, $key, $classid);
    return undef if $dbh->err;
    my $fid = $dbh->{mysql_insertid};  # FIXME: mysql-ism
    return undef unless $fid > 0;

    # find a device to put this file on that has 100Mb free.
    # FIXME: make this use get_device_summary, removing this SQL:
    my $devids = $dbh->selectcol_arrayref("SELECT devid FROM device ".
                                          "WHERE status='alive' AND (mb_used IS NULL ".
                                          "   OR (mb_total-mb_used > 100))");
    my $count = $devids ? @$devids : 0;
    return $self->err_line("no_devices") unless $count;

    # pick a random alive device
    my $devid = $devids->[int(rand($count))];

    # FIXME: verify the path is good, and try alt device otherwise
    my $path = Mgd::make_path($devid, $fid);

    # make a note that this file will be going here, so if it's
    # partially written and aborted, or closed, the cleanup
    # process will know what to cleanup
    $dbh->do("INSERT IGNORE INTO file_on SET fid=?, devid=?",
             undef, $fid, $devid);

    return $self->ok_line({
        fid => $fid,
        devid => $devid,
        path => $path,
    });
}

sub cmd_create_close {
    my Worker $self = shift;
    my $args = shift;

    # validate parameters
    my $dmid = $self->check_domain($args) or return 0;
    my $key = $args->{key};

    my $fid = $args->{fid} or return $self->err_line("no_fid");
    my $devid = $args->{devid} or return $self->err_line("no_devid");
    my $path = $args->{path} or return $self->err_line("no_path");

    # is the provided path what we'd expect for this fid/devid?
    return $self->err_line("bogus_args")
        unless $path eq Mgd::make_path($devid, $fid);

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");

    # find the temp file we're closing and making real
    my $trow = $dbh->selectrow_hashref("SELECT classid, dmid, dkey ".
                                       "FROM tempfile WHERE fid=?",
                                       undef, $fid);
    return $self->err_line("no_temp_file") unless $trow;

    # if a temp file is closed without a provided-key, that means to
    # delete it.
    unless (length($key)) {
        # add to to-delete list
        $dbh->do("REPLACE INTO file_to_delete SET fid=?", undef, $fid);
        $dbh->do("DELETE FROM tempfile WHERE fid=?", undef, $fid);
        return $self->ok_line;
    }

    # see if we have a fid for this key already
    my $old_file = Mgd::key_filerow($dbh, $dmid, $key);
    if ($old_file) {
        # add to to-delete list
        $dbh->do("REPLACE INTO file_to_delete SET fid=?", undef, $old_file->{fid});
        $dbh->do("DELETE FROM file WHERE fid=?", undef, $old_file->{fid});
    }

    # get size of file and verify that it matches what we were given, if anything
    my $size = Mgd::get_file_size($path);
    return $self->err_line("size_mismatch", "Expected: $args->{size}; actual: $size; path: $path")
        if $args->{size} && ($args->{size} != $size);

    # TODO: check for EIO?
    return $self->err_line("empty_file") unless $size;

    my $rv = $dbh->do("REPLACE INTO file ".
                      "SET ".
                      "  fid=?, dmid=?, dkey=?, length=?, ".
                      "  classid=?, devcount=0", undef,
                      $fid, $dmid, $key, $size, $trow->{classid});
    return $self->err_line("db_error") unless $rv;

    $dbh->do("DELETE FROM tempfile WHERE fid=?", undef, $fid);

    if (Mgd::update_fid_devcount($fid)) {
        return $self->ok_line();
    } else {
        # FIXME: handle this better
        return $self->err_line("db_error");
    }
}

sub cmd_delete {
    my Worker $self = shift;
    my $args = shift;

    # validate parameters
    my $dmid = $self->check_domain($args) or return 0;
    my $key = $args->{key};
    return $self->err_line("no_key") unless length($key);

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");

    # is this fid still owned by this key?
    my $fid = $dbh->selectrow_array("SELECT fid FROM file WHERE dmid=? AND dkey=?",
                                    undef, $dmid, $key);
    return $self->err_line("unknown_key") unless $fid;

    $dbh->do("DELETE FROM file WHERE fid=?", undef, $fid);
    $dbh->do("REPLACE INTO file_to_delete SET fid=?", undef, $fid);

    return $self->ok_line();

}

sub cmd_rename {
    my Worker $self = shift;
    my $args = shift;

    # validate parameters
    my $dmid = $self->check_domain($args) or return 0;
    my ($fkey, $tkey) = ($args->{from_key}, $args->{to_key});
    return $self->err_line("no_key") unless $fkey && $tkey;

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");

    # rename the file
    my $ct = $dbh->do('UPDATE file SET dkey = ? WHERE dmid = ? AND dkey = ?',
                      undef, $tkey, $dmid, $fkey);
    return $self->err_line("key_exists") if $dbh->err;
    return $self->err_line("unknown_key") unless $ct > 0;

    return $self->ok_line();
}

sub cmd_get_hosts {
    my Worker $self = shift;
    my $args = shift;

    my $dbh = Mgd::get_dbh()
        or return $self->err_line("nodb");

    Mgd::check_host_cache();

    my $ret = { hosts => 0 };
    while (my ($hostid, $row) = each %Mgd::cache_host) {
        next if defined $args->{hostid} && $hostid != $args->{hostid};

        $ret->{hosts}++;
        while (my ($key, $val) = each %$row) {
            $ret->{"host$ret->{hosts}_$key"} = $val;
        }
    }

    return $self->ok_line($ret);
}

sub cmd_get_devices {
    my Worker $self = shift;
    my $args = shift;

    my $dbh = Mgd::get_dbh()
        or return $self->err_line("nodb");

    my $devs = Mgd::get_device_summary();

    my $ret = { devices => 0 };
    while (my ($devid, $row) = each %$devs) {
        next if defined $args->{devid} && $devid != $args->{devid};

        $ret->{devices}++;
        while (my ($key, $val) = each %$row) {
            $ret->{"dev$ret->{devices}_$key"} = $val;
        }
    }

    return $self->ok_line($ret);
}

sub cmd_create_domain {
    my Worker $self = shift;
    my $args = shift;

    my $dbh = Mgd::get_dbh()
        or return $self->err_line("nodb");

    my $domain = $args->{domain};
    return $self->err_line('no_domain') unless length $domain;

    # FIXME: add some sort of authentication/limitation on this?
    
    my $dmid = Mgd::domain_id($domain);
    return $self->err_line('domain_exists') if $dmid;

    # get the max domain id
    my $maxid = $dbh->selectrow_array('SELECT MAX(dmid) FROM domain');
    $dbh->do('INSERT INTO domain (dmid, namespace) VALUES (?, ?)',
             undef, $maxid + 1, $domain);
    return $self->err_line('failure') if $dbh->err;

    # return the domain id we created
    return $self->ok_line({ domain => $domain });
}

sub cmd_create_class {
    my Worker $self = shift;
    my $args = shift;

    my $dbh = Mgd::get_dbh()
        or return $self->err_line("nodb");

    my $domain = $args->{domain};
    return $self->err_line('no_domain') unless length $domain;

    my $class = $args->{class};
    return $self->err_line('no_class') unless length $class;

    my $mindevcount = $args->{mindevcount}+0;
    return $self->err_line('invalid_mindevcount') unless $mindevcount > 0;

    # FIXME: add some sort of authentication/limitation on this?
    
    my $dmid = Mgd::domain_id($domain);
    return $self->err_line('no_domain') unless $dmid;

    my $cid = Mgd::class_id($dmid, $class);
    return $self->err_line('class_exists') if $cid && !$args->{update};

    # update or insert at this point
    if ($args->{update}) {
        # now replace the old class
        $dbh->do("REPLACE INTO class (dmid, classid, classname, mindevcount) VALUES (?, ?, ?, ?)",
                 undef, $dmid, $cid, $class, $mindevcount);
    } else {
        # get the max class id in this domain
        my $maxid = $dbh->selectrow_array
            ('SELECT MAX(classid) FROM class WHERE dmid = ?', undef, $dmid);

        # now insert the new class
        $dbh->do("INSERT INTO class (dmid, classid, classname, mindevcount) VALUES (?, ?, ?, ?)",
                 undef, $dmid, $maxid + 1, $class, $mindevcount);
    }
    return $self->err_line('failure') if $dbh->err;

    # return success
    return $self->ok_line({ class => $class, mindevcount => $mindevcount, domain => $domain });
}

sub cmd_update_class {
    my Worker $self = shift;
    my $args = shift;

    # simply passes through to create_class with update set
    $self->cmd_create_class({ %$args, update => 1 });
}

sub cmd_get_domains {
    my Worker $self = shift;
    my $args = shift;

    my $dbh = Mgd::get_dbh()
        or return $self->err_line("nodb");

    my $domains = $dbh->selectall_arrayref('SELECT dmid, namespace FROM domain');

    my $ret = {};
    my $outercount = 0;
    foreach my $row (@$domains) {
        $ret->{"domain" . ++$outercount} = $row->[1];

        # setup the return row for this set of classes
        my $classes = $dbh->selectall_arrayref
            ('SELECT classname, mindevcount FROM class WHERE dmid = ?', undef, $row->[0]);
        my $innercount = 0;
        foreach my $irow (@$classes) {
            $ret->{"domain${outercount}class" . ++$innercount . "name"} = $irow->[0];
            $ret->{"domain${outercount}class" . $innercount . "mindevcount"} = $irow->[1];
        }

        # record the default class and mindevcount
        $ret->{"domain${outercount}class" . ++$innercount . "name"} = 'default';
        $ret->{"domain${outercount}class" . $innercount . "mindevcount"} = $default_mindevcount;
        
        $ret->{"domain${outercount}classes"} = $innercount;
    }
    $ret->{"domains"} = $outercount;

    return $self->ok_line($ret);
}

sub cmd_get_paths {
    my Worker $self = shift;
    my $args = shift;

    my $key = $args->{key};

    return $self->err_line("no_key") unless length($key);

    # validate domain
    my $dmid = $self->check_domain($args) or return 0;

    # get DB handle
    my $dbh = Mgd::get_dbh or
        return $self->err_line("nodb");
    
    my $filerow = Mgd::key_filerow($dbh, $dmid, $key);
    return $self->err_line("unknown_key") unless $filerow;

    my $fid = $filerow->{fid};
    my $dsum = Mgd::get_device_summary();

    my $ret = {
        paths => 0,
    };

    # is this fid still owned by this key?
    my $devids = $dbh->selectcol_arrayref("SELECT devid FROM file_on WHERE fid=?",
                                          undef, $fid) || [];
    my $devcount = scalar(@$devids);
    my $idx = int(rand() * $devcount);

    for (1..$devcount) {
        my $devid = $devids->[($_+$idx) % $devcount];
        my $dev = $dsum->{$devid};
        next unless $dev && $dev->{status} eq "alive";
        my $path = Mgd::make_path($devid, $fid);
        next unless $ret->{paths} || $args->{noverify} ||
                        (Mgd::get_file_size($path) == $filerow->{length});
        my $n = ++$ret->{paths};
        $ret->{"path$n"} = $path;
        last if $n == 2;   # one verified, one likely seems enough for now.  time will tell.
    }

    return $self->ok_line($ret);
}

sub cmd_set_state {
    my Worker $self = shift;
    my $args = shift;

    # get database handle
    my $ret = {};
    my $dbh = Mgd::get_dbh
        or return $self->err_line('nodb');

    # figure out what they want to do
    my ($host, $dev, $state) = ($args->{host}, $args->{device}+0, $args->{state});
    return $self->err_line('bad_params')
        unless $host && $dev && ($state =~ /^(?:alive|down|dead)$/);

    # now get this device's current state and host
    my ($realhost, $curstate) =
        $dbh->selectrow_array('SELECT hostname, device.status FROM host, device ' .
                              'WHERE host.hostid = device.hostid AND device.devid = ?',
                              undef, $dev);

    # verify host is the same
    return $self->err_line('host_mismatch')
        unless $realhost eq $host;

    # make sure the destination state isn't too high
    return $self->err_line('state_too_high')
        if $curstate eq 'dead' && $state eq 'alive';

    # update the state in the database now
    $dbh->do('UPDATE device SET status = ? WHERE devid = ?', undef, $state, $dev);
    return $self->err_line('failure') if $dbh->err;

    # success, state changed
    return $self->ok_line($ret);
}

sub cmd_stats {
    my Worker $self = shift;
    my $args = shift;

    # get database handle
    my $ret = {};
    my $dbh = Mgd::get_dbh
        or return $self->err_line('nodb');

    # get names of all domains and classes for use later
    my %classes;
    my $rows = $dbh->selectall_arrayref('SELECT class.dmid, namespace, classid, classname ' .
                                        'FROM domain, class WHERE class.dmid = domain.dmid');
    foreach my $row (@$rows) {
        $classes{$row->[0]}->{name} = $row->[1];
        $classes{$row->[0]}->{classes}->{$row->[2]} = $row->[3];
    }
    $classes{$_}->{classes}->{0} = 'default'
        foreach keys %classes;

    # get host and device information with device status
    my %devices;
    my $rows = $dbh->selectall_arrayref('SELECT device.devid, hostname, device.status ' .
                                        'FROM device, host WHERE device.hostid = host.hostid');
    foreach my $row (@$rows) {
        $devices{$row->[0]}->{host} = $row->[1];
        $devices{$row->[0]}->{status} = $row->[2];
    }

    # if they want replication counts, or didn't specify what they wanted
    if ($args->{replication} || $args->{all}) {
        # replication stats
        my $stats = $dbh->selectall_arrayref('SELECT dmid, classid, devcount, COUNT(devcount) FROM file GROUP BY 1, 2, 3');
        my $count = 0;
        foreach my $stat (@$stats) {
            $count++;
            $ret->{"replication${count}domain"} = $classes{$stat->[0]}->{name};
            $ret->{"replication${count}class"} = $classes{$stat->[0]}->{classes}->{$stat->[1]};
            $ret->{"replication${count}devcount"} = $stat->[2];
            $ret->{"replication${count}files"} = $stat->[3];
        }
        $ret->{"replicationcount"} = $count;
    }

    # file statistics (how many files there are and in what domains/classes)
    if ($args->{files} || $args->{all}) {
        my $stats = $dbh->selectall_arrayref('SELECT dmid, classid, COUNT(classid) FROM file GROUP BY 1, 2');
        my $count = 0;
        foreach my $stat (@$stats) {
            $count++;
            $ret->{"files${count}domain"} = $classes{$stat->[0]}->{name};
            $ret->{"files${count}class"} = $classes{$stat->[0]}->{classes}->{$stat->[1]};
            $ret->{"files${count}files"} = $stat->[2];
        }
        $ret->{"filescount"} = $count;
    }

    # device statistics (how many files are on each device)
    if ($args->{devices} || $args->{all}) {
        my $stats = $dbh->selectall_arrayref('SELECT devid, COUNT(devid) FROM file_on GROUP BY 1');
        my $count = 0;
        foreach my $stat (@$stats) {
            $count++;
            $ret->{"devices${count}id"} = $stat->[0];
            $ret->{"devices${count}host"} = $devices{$stat->[0]}->{host};
            $ret->{"devices${count}status"} = $devices{$stat->[0]}->{status};
            $ret->{"devices${count}files"} = $stat->[1];
        }
        $ret->{"devicescount"} = $count;
    }

    # FIXME: DO! add other stats

    return $self->ok_line($ret);
}

sub ok_line {
    my Worker $self = shift;
    my $args = shift;
    my $argline = join('&', map { eurl($_) . "=" . eurl($args->{$_}) } keys %$args);
    $self->{sock}->print("OK $argline\r\n");
    return 1;
}

# first argument: error code.
# second argument: optional error text.  text will be taken from code if no text provided.
sub err_line {
    my Worker $self = shift;
    my $err_code = shift;
    my $err_text = shift || {
        'unknown_command' => "Unknown server command",
        'no_domain' => "No domain provided",
        'no_class' => "No class provided",
        'class_exists' => "That class already exists in that domain",
        'domain_exists' => "That domain already exists",
        'invalid_mindevcount' => "The mindevcount must be at least 1",
        'bad_params' => "Invalid parameters to command; please see documentation",
        'host_mismatch' => "The device specified doesn't belong to the host specified",
        'state_too_high' => "Status cannot go from dead to alive; must use down",
        'failure' => "Operation failed",
        'key_exists' => "Target key name already exists; can't overwrite.",
    }->{$err_code};

    $self->{sock}->print("ERR $err_code " . eurl($err_text) . "\r\n");
    return 0;
}

sub eurl
{
    my $a = $_[0];
    $a =~ s/([^a-zA-Z0-9_\,\-.\/\\\: ])/uc sprintf("%%%02x",ord($1))/eg;
    $a =~ tr/ /+/;
    return $a;
}

sub decode_url_args
{
    my $a = shift;
    my $buffer = ref $a ? $a : \$a;
    my $ret = {};

    my $pair;
    my @pairs = split(/&/, $$buffer);
    my ($name, $value);
    foreach $pair (@pairs)
    {
        ($name, $value) = split(/=/, $pair);
        $value =~ tr/+/ /;
        $value =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $name =~ tr/+/ /;
        $name =~ s/%([a-fA-F0-9][a-fA-F0-9])/pack("C", hex($1))/eg;
        $ret->{$name} .= $ret->{$name} ? "\0$value" : $value;
    }
    return $ret;
}


# Local Variables:
# mode: perl
# c-basic-indent: 4
# indent-tabs-mode: nil
# End:
